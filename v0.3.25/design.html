<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Framework design · AlgebraicAgents.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">AlgebraicAgents.jl</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">API Documentation</a></li><li><a class="tocitem" href="design_mmd.html">Framework design</a></li><li><a class="tocitem" href="integrations.html">Integrations</a></li><li><span class="tocitem">Sketches</span><ul><li><a class="tocitem" href="sketches/agents/agents.html">Agents.jl Integration</a></li><li><a class="tocitem" href="sketches/molecules/molecules.html">A Toy Pharma Model</a></li><li><a class="tocitem" href="sketches/sciml/sciml.html">SciML Integration</a></li><li><a class="tocitem" href="sketches/algebraicdynamics/algebraicdynamics.html">Lotka-Voltera Two Ways</a></li><li><a class="tocitem" href="sketches/stochastic_simulation/anderson.html">Simulating Stochastic Reaction Systems</a></li><li><a class="tocitem" href="sketches/relations/relations.html">Relations and Concepts</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="design.html">Framework design</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="design.html">Framework design</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Merck/AlgebraicAgents.jl/blob/main/docs/src/design.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><script type="module">
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@9/dist/mermaid.esm.min.mjs';
  mermaid.initialize({ startOnLoad: true });
</script><script type="module">
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@9/dist/mermaid.esm.min.mjs';
  mermaid.initialize({ startOnLoad: true });
</script><h1 id="Framework-design"><a class="docs-heading-anchor" href="#Framework-design">Framework design</a><a id="Framework-design-1"></a><a class="docs-heading-anchor-permalink" href="#Framework-design" title="Permalink"></a></h1><p>Here we describe the design principles of the AlgebraicAgents. It should be of most use to advanced users and persons interested in contributing to the software. New users are encouraged to start by reading one of the tutorials (&quot;sketches&quot;).</p><h2 id="Simulation-loop"><a class="docs-heading-anchor" href="#Simulation-loop">Simulation loop</a><a id="Simulation-loop-1"></a><a class="docs-heading-anchor-permalink" href="#Simulation-loop" title="Permalink"></a></h2><p>We describe here the main simulation loop which steps models built in AlgebraicAgents forward in time.</p><p>AlgebraicAgents keeps agents synchronized by ensuring that the model will only simulate the agent(s) whose projected time (e.g. the maximum time for which that agent&#39;s trajectory has been solved) is the minimum of all agents. For example, if there are 3 agents, whose internal step sizes are of 1, 1.5, and 3 time units, respectively, then at the end of the first step, their projected time will be 1, 1.5, and 3 (assuming they all start at time 0). The simulation will find the minimum of those times and only simulate the agent(s) whose projected time(s) are equal to the minimum. In this case, it is the first agent, who is now projected to time 2 on the second step (other agents are not simulated). Now, the new minimum time is 1.5, and the second agent is projected to time 3 on the third step, etc. The simulation continues until all agents have been projected to their final time point, or the minimum of projected times reaches a maximum time horizon. If all agents take time steps of the same size, then they will all be updated each global step.</p><p>There are several functions in the interface for an <a href="index.html#AlgebraicAgents.AbstractAlgebraicAgent"><code>AbstractAlgebraicAgent</code></a> which implement these dynamics. When defining new agent types, one should implement the <a href="index.html#AlgebraicAgents._step!-Tuple{AbstractAlgebraicAgent}"><code>AlgebraicAgents._step!</code></a> method, which will step that agent forward if its projected time is equal to the least projected time, among all agents in the hierarchy. Agent types also need to implement <a href="index.html#AlgebraicAgents._projected_to-Tuple{AbstractAlgebraicAgent}"><code>AlgebraicAgents._projected_to</code></a>, which is crucial to keeping the simulation synchronized. It will return:</p><ul><li><code>nothing</code> if the agent does not implement its own <code>_step!</code> rule (e.g. <a href="index.html#AlgebraicAgents.FreeAgent"><code>FreeAgent</code></a> which is a container of agents)</li><li><code>true</code> if the agent has been projected to the final time point (<code>_step!</code> will not be called again)</li><li>a value of <code>Number</code>, giving the time point to which the agent has been projected</li></ul><p>These are collected into <code>ret</code>, which is an object that will be <code>true</code> if and only if all agents have returned <code>true</code>, and is otherwise the minimum of the numeric values (projection times) returned from each inner agent&#39;s step.</p><div class="mermaid">

flowchart TD

    Start((Enter Program))-->Project[Set t equal to minimum \n projected time]:::GreenNode

    Project-->RootDecision1{is root?}:::YellowNode
    
    RootDecision1 -->|yes| PreWalk[Prestep inner agents]:::GreenNode

    RootDecision1 -->|no| Step[Step inner agents]:::GreenNode

    PreWalk -.->|_prestep!| Inners([<:AbstractAlgebraicAgent]):::RedNode
    
    PreWalk --> Step

    Step -.->|step!| Inners

    subgraph inners
    Inners
    end

    Ret([ret]):::RedNode

    Inners -.->|_projected_to| Ret

    Step --> LocalDecision{local projected time == t\n equals the min projected time}:::YellowNode

    LocalDecision -->|yes| LocalStep[Local step]:::GreenNode
    LocalDecision -->|no| RootDecision2{is root?}:::YellowNode

    LocalStep -.->|_projected_to| Ret

    LocalStep --> RootDecision2

    subgraph Opera

    RootDecision2 -->|yes| InstantOpera[Execute instantaneous interactions]:::GreenNode
    InstantOpera --> FutureOpera[Execute delayed interactions]:::GreenNode
    FutureOpera --> ControlOpera[Execute control interactions]:::GreenNode
    end

    Opera -.->|_projected_to| Ret

    RootDecision2 -->|no| Stop

    ControlOpera --> Stop((Exit program and\n return ret))

    classDef GreenNode fill:#D5E8D4,stroke:#82B366;
    classDef RedNode fill:#F8CECC,stroke:#B85450;
    classDef YellowNode fill:#FFE6CC,stroke:#D79B00;

</div><p>Above we show a caricature of the main simulation loop. &quot;Enter program&quot; corresponds to the call to <code>simulate</code>, the value of <code>ret</code> is (typically) initialized to <code>0.0</code>. The simulation continues to step while <code>ret</code> is not <code>true</code> (meaning the maximum time horizon has been reached by the slowest agent), or has not exceeded some maximum. </p><p>The inner area enclosed by a dashed border represents where program control is given to the <code>step!</code> method. The root agent applies <code>_prestep!</code> recurvisely to all of its inner (enclosed) agents. After this, <code>step!</code> is then applied to all inner agents, and <code>ret</code> is updated by each of them. Then the agent applies its own local update <code>_step!</code> if its own projected time is equal to the minimum of all inner agent projected times (not shown). Then the Opera module for additional interactions is called for the root agent.</p><h2 id="Opera"><a class="docs-heading-anchor" href="#Opera">Opera</a><a id="Opera-1"></a><a class="docs-heading-anchor-permalink" href="#Opera" title="Permalink"></a></h2><p>The Opera system allows interactions between agents to be scheduled. By default, AlgebraicAgents.jl provides support for three types of interactions:</p><ul><li><strong>futures (delayed interactions)</strong></li><li><strong>system controls</strong></li><li><strong>instantious interactions</strong></li></ul><p>For more details, see the API documentation of <a href="index.html#AlgebraicAgents.Opera"><code>Opera</code></a> and our tests.</p><h3 id="Futures"><a class="docs-heading-anchor" href="#Futures">Futures</a><a id="Futures-1"></a><a class="docs-heading-anchor-permalink" href="#Futures" title="Permalink"></a></h3><p>You may schedule function calls, to be executed at predetermined points of time. An action is modeled as a tuple <code>(id, call, time)</code>, where <code>id</code> is an optional textual identifier of the action and <code>call</code> is a (parameterless) anonymous function, which will be called at the given <code>time</code>. Once the action is executed, the return value with corresponding action id and execution time is added to <code>futures_log</code> field of <code>Opera</code> instance.</p><p>See <a href="index.html#AlgebraicAgents.add_future!"><code>add_future!</code></a> and <a href="index.html#AlgebraicAgents.@future"><code>@future</code></a>.</p><h4 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h4><pre><code class="language-julia hljs">alice = MyAgentType(&quot;alice&quot;)
interact = agent -&gt; wake_up!(agent)
@future alice 5.0 interact(alice) &quot;alice_schedule&quot;</code></pre><p>The solver will stop at <code>t=5</code> and call the function <code>() -&gt; interact(alice)</code> (a closure is taken at the time when <code>@future</code> is invoked). This interaction is identified as <code>&quot;alice_schedule&quot;</code>.</p><h3 id="Control-Interactions"><a class="docs-heading-anchor" href="#Control-Interactions">Control Interactions</a><a id="Control-Interactions-1"></a><a class="docs-heading-anchor-permalink" href="#Control-Interactions" title="Permalink"></a></h3><p>You may schedule control function calls, to be executed at every step of the model. An action is modeled as a tuple <code>(id, call)</code>, where <code>id</code> is an optional textual identifier of the action, and <code>call</code> is a (parameterless) anonymous function. Once the action is executed, the return value with corresponding action id and execution time is added to <code>controls_log</code> field of <code>Opera</code> instance.</p><p>See <a href="index.html#AlgebraicAgents.add_control!"><code>add_control!</code></a> and <a href="index.html#AlgebraicAgents.@control"><code>@control</code></a>.</p><h4 id="Example-2"><a class="docs-heading-anchor" href="#Example-2">Example</a><a class="docs-heading-anchor-permalink" href="#Example-2" title="Permalink"></a></h4><pre><code class="language-julia hljs">system = MyAgentType(&quot;system&quot;)
control = agent -&gt; agent.temp &gt; 100 &amp;&amp; cool!(agent)
@control system control(system) &quot;temperature control&quot;</code></pre><p>At each step, the solver will call the function <code>() -&gt; control(system)</code> (a closure is taken at the time when <code>@future</code> is invoked).</p><h3 id="Instantious-Interactions"><a class="docs-heading-anchor" href="#Instantious-Interactions">Instantious Interactions</a><a id="Instantious-Interactions-1"></a><a class="docs-heading-anchor-permalink" href="#Instantious-Interactions" title="Permalink"></a></h3><p>You may schedule additional interactions which exist within a single step of the model; such actions are modeled as named tuples <code>(id, priority=0., call)</code>. Here, <code>call</code> is a (parameterless) anonymous function.</p><p>They exist within a single step of the model and are executed after the calls to <code>_prestep!</code> and <code>_step!</code> finish, in the order of the assigned priorities.</p><p>In particular, you may schedule interactions of two kinds:</p><ul><li><code>poke(agent, priority)</code>, which will translate into a call <code>() -&gt; _interact!(agent)</code>, with the specified priority,</li><li><code>@call opera expresion priority</code>, which will translate into a call <code>() -&gt; expression</code>, with the specified priority.</li></ul><p>See <a href="index.html#AlgebraicAgents.poke"><code>poke</code></a> and <a href="index.html#AlgebraicAgents.@call"><code>@call</code></a>.</p><h4 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h4><pre><code class="language-julia hljs"># `poke`
poke(agent, 1.) # call `_interact!(agent)`; this call is added to the instantious priority queue with priority 1</code></pre><pre><code class="language-julia hljs"># `@call`
bob_agent = only(getagent(agent, r&quot;bob&quot;))
@call agent wake_up(bob_agent) # translates into `() -&gt; wake_up(bob_agent)` with priority 0</code></pre><h2 id="Concepts,-Relations,-and-Wires"><a class="docs-heading-anchor" href="#Concepts,-Relations,-and-Wires">Concepts, Relations, and Wires</a><a id="Concepts,-Relations,-and-Wires-1"></a><a class="docs-heading-anchor-permalink" href="#Concepts,-Relations,-and-Wires" title="Permalink"></a></h2><p>AlgebraicAgents.jl is designed to enable semantic modeling of complex systems by representing key elements as concepts, the relations between them, and agents connected via wires that explicitly define information flow. While leveraging these features is entirely optional and not required for the core functionality of the library, they offer powerful tools for model comprehension, visualization, querying, and debugging.</p><h3 id="Concepts-and-Relations"><a class="docs-heading-anchor" href="#Concepts-and-Relations">Concepts and Relations</a><a id="Concepts-and-Relations-1"></a><a class="docs-heading-anchor-permalink" href="#Concepts-and-Relations" title="Permalink"></a></h3><p>A concept is a subtype of <a href="index.html#AlgebraicAgents.AbstractConcept"><code>AbstractConcept</code></a> and represents an entity characterized by a name and an internal parameter space. Both concepts and agents belong to the union type <code>RelatableType</code>, allowing flexible relationships to be established between any two relatable entities—for example, between agents and concepts or between agents themselves.</p><p>Relations are oriented, meaning each relation has a designated source, target, and a relation type, represented as a Symbol. These complex relationships can be effectively visualized using the <a href="index.html#AlgebraicAgents.concept_graph"><code>concept_graph</code></a> function, providing insights into the structure and interconnections within the model.</p><p>Consider the following example. First, we set up the hierarchy.</p><p>Next we define generic concepts and their relations. Concepts are defined using the <a href="index.html#AlgebraicAgents.Concept"><code>Concept</code></a> type, which can be used to create abstract containers for data, requests, responses, etc. Relations between concepts and agents are established using the <a href="index.html#AlgebraicAgents.add_relation!"><code>add_relation!</code></a> function.</p><pre><code class="language-julia hljs">c_data = Concept(&quot;Data&quot;, Dict(:format =&gt; &quot;binary&quot;)) # abstract container
c_request = Concept(&quot;Request&quot;, Dict(:purpose =&gt; &quot;query&quot;)) # a kind of Data
c_response = Concept(&quot;Response&quot;, Dict(:purpose =&gt; &quot;reply&quot;)) # a kind of Data

# Bind all Concepts into our system
add_concept!(system, c_data)
# Multiple concepts can be added at once.
add_concept!.(Ref(system), [c_request, c_response])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Vector{AbstractConcept}}:
 [Concept{name=Data, uuid=57bbfc49, related_entities=}, Concept{name=Request, uuid=493f132b, related_entities=}, Concept{name=Response, uuid=9f9e16de, related_entities=}]
 [Concept{name=Data, uuid=57bbfc49, related_entities=}, Concept{name=Request, uuid=493f132b, related_entities=}, Concept{name=Response, uuid=9f9e16de, related_entities=}]</code></pre><p>Next, we can establish relations between agents and concepts, as well as between concepts themselves. This allows us to define the roles of agents in the system and how they interact with the concepts.</p><pre><code class="language-julia hljs"># ----- Set up Concept–Concept relations -----

# Request ⊂ Data
add_relation!(c_request, c_data, :is_a)
# Response ⊂ Data
add_relation!(c_response, c_data, :is_a)

# ----- Set up Agent–Concept relations -----

# Client produces requests and consumes responses
add_relation!(client, c_request,  :produces)
add_relation!(client, c_response, :consumes)

# Server consumes requests and produces responses
add_relation!(server, c_request,  :consumes)
add_relation!(server, c_response, :produces)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">relation <span class="sgr36"><span class="sgr1">server</span></span> [agent] <span class="sgr35">produces</span> <span class="sgr36"><span class="sgr1">Response</span></span> [concept]</code></pre><p>Now we can query the relations.</p><pre><code class="language-julia hljs"># Query related concepts/agents
println(&quot;Entities related to Data:&quot;)
for r in get_relations(c_data)
    println(r)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Entities related to Data:
AlgebraicAgents.ConceptRelation{from=Request, relation=is_a, to=Data}
AlgebraicAgents.ConceptRelation{from=Response, relation=is_a, to=Data}</code></pre><pre><code class="language-julia hljs">println(&quot;Entites that Client produces:&quot;)
for r in get_relations(client, :produces)
    println(r)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Entites that Client produces:
AlgebraicAgents.ConceptRelation{from=client, relation=produces, to=Request}</code></pre><pre><code class="language-julia hljs">isrelated(client, c_request, :produces) == true</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>We can also visualize the concept graph, which shows the relations between concepts and agents in the system.</p><pre><code class="language-julia hljs"># ----- Visualize the wires and relations -----

# Visualize the wiring diagram of the system
run_graphviz(&quot;gv1.svg&quot; ,wiring_diagram(system))</code></pre><p><img src="gv1.svg" alt/></p><pre><code class="language-julia hljs"># Visualize the concept graph of the system
run_graphviz(&quot;gv2.svg&quot;, concept_graph(get_relation_closure(server)))</code></pre><p><img src="gv2.svg" alt/></p><p>Finally, we show how to remove concepts and relations. This can be useful for cleaning up the model or when concepts are no longer relevant.</p><pre><code class="language-julia hljs"># Remove the concept-to-concept relation
remove_relation!(c_data, c_request, :is_a)

# Remove the Fruit concept entirely
remove_concept!(server, c_request)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">concept <span class="sgr36"><span class="sgr1">Request</span></span> with uuid <span class="sgr36">493f132b</span> of type <span class="sgr36">Concept</span></code></pre><h3 id="Wires"><a class="docs-heading-anchor" href="#Wires">Wires</a><a id="Wires-1"></a><a class="docs-heading-anchor-permalink" href="#Wires" title="Permalink"></a></h3><p>It is possible to explicitly establish oriented &quot;wires&quot; along which information flows between different agents in a hierarchy. Note that it is optional to define these wires and in general, it is possible to retrieve and modify the state of any other agent from within any agent, in any way. However, in some cases, it may be desirable to explicitly specify that certain agents observe a particular state variable of another agent, for example, to visualize the information flow in a model, or to query the state of the system in a more structured way.</p><p>Consider the following example. First, we set up the hierarchy.</p><pre><code class="language-julia hljs">alice = MyAgentType(&quot;alice&quot;)
alice1 = MyAgentType(&quot;alice1&quot;)
entangle!(alice, alice1)

bob = MyAgentType(&quot;bob&quot;)
bob1 = MyAgentType(&quot;bob1&quot;)
entangle!(bob, bob1)

joint_system = ⊕(alice, bob, name = &quot;joint system&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">agent <span class="sgr32"><span class="sgr1">joint system </span></span>with uuid <span class="sgr32">26bc8fb5 </span>of type <span class="sgr32">FreeAgent </span>
   <span class="sgr1">inner agents: </span>
    agent <span class="sgr32"><span class="sgr1">alice </span></span>with uuid <span class="sgr32">19c4439c </span>of type <span class="sgr32">Main.MyAgentType </span>
       <span class="sgr1">inner agents: </span>alice1
    agent <span class="sgr32"><span class="sgr1">bob </span></span>with uuid <span class="sgr32">97c56935 </span>of type <span class="sgr32">Main.MyAgentType </span>
       <span class="sgr1">inner agents: </span>bob1</code></pre><p>We then add the wires. Note that the agents connected by a wire can be specified using the respective agent objects, relative paths, or their UUIDs.</p><p>Additionally, you can assign names to the edges of a wire (which are <code>nothing</code> by default). These names can subsequently be used to fetch the information incoming along an edge, a process that we will describe below.</p><pre><code class="language-julia hljs">add_wire!(joint_system; from=alice, to=bob, from_var_name=&quot;alice_x&quot;, to_var_name=&quot;bob_x&quot;)
add_wire!(joint_system; from=bob, to=alice, from_var_name=&quot;bob_y&quot;, to_var_name=&quot;alice_y&quot;)

add_wire!(joint_system; from=alice, to=alice1, from_var_name=&quot;alice_x&quot;, to_var_name=&quot;alice1_x&quot;)
add_wire!(joint_system; from=bob, to=bob1, from_var_name=&quot;bob_x&quot;, to_var_name=&quot;bob1_x&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{NamedTuple{(:from, :from_var_name, :to, :to_var_name), &lt;:Tuple{AbstractAlgebraicAgent, Any, AbstractAlgebraicAgent, Any}}}:
 (from = Main.MyAgentType{name=alice, uuid=19c4439c, parent=FreeAgent{name=joint system, uuid=26bc8fb5, parent=nothing}}, from_var_name = &quot;alice_x&quot;, to = Main.MyAgentType{name=bob, uuid=97c56935, parent=FreeAgent{name=joint system, uuid=26bc8fb5, parent=nothing}}, to_var_name = &quot;bob_x&quot;)
 (from = Main.MyAgentType{name=bob, uuid=97c56935, parent=FreeAgent{name=joint system, uuid=26bc8fb5, parent=nothing}}, from_var_name = &quot;bob_y&quot;, to = Main.MyAgentType{name=alice, uuid=19c4439c, parent=FreeAgent{name=joint system, uuid=26bc8fb5, parent=nothing}}, to_var_name = &quot;alice_y&quot;)
 (from = Main.MyAgentType{name=alice, uuid=19c4439c, parent=FreeAgent{name=joint system, uuid=26bc8fb5, parent=nothing}}, from_var_name = &quot;alice_x&quot;, to = Main.MyAgentType{name=alice1, uuid=b0dd07be, parent=Main.MyAgentType{name=alice, uuid=19c4439c, parent=FreeAgent{name=joint system, uuid=26bc8fb5, parent=nothing}}}, to_var_name = &quot;alice1_x&quot;)
 (from = Main.MyAgentType{name=bob, uuid=97c56935, parent=FreeAgent{name=joint system, uuid=26bc8fb5, parent=nothing}}, from_var_name = &quot;bob_x&quot;, to = Main.MyAgentType{name=bob1, uuid=6093063d, parent=Main.MyAgentType{name=bob, uuid=97c56935, parent=FreeAgent{name=joint system, uuid=26bc8fb5, parent=nothing}}}, to_var_name = &quot;bob1_x&quot;)</code></pre><p>We list the wires going from and to <code>alice</code> and <code>alice1</code>, respectively.</p><pre><code class="language-julia hljs">get_wires_from(alice)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{NamedTuple{(:from, :from_var_name, :to, :to_var_name), &lt;:Tuple{AbstractAlgebraicAgent, Any, AbstractAlgebraicAgent, Any}}}:
 (from = Main.MyAgentType{name=alice, uuid=19c4439c, parent=FreeAgent{name=joint system, uuid=26bc8fb5, parent=nothing}}, from_var_name = &quot;alice_x&quot;, to = Main.MyAgentType{name=bob, uuid=97c56935, parent=FreeAgent{name=joint system, uuid=26bc8fb5, parent=nothing}}, to_var_name = &quot;bob_x&quot;)
 (from = Main.MyAgentType{name=alice, uuid=19c4439c, parent=FreeAgent{name=joint system, uuid=26bc8fb5, parent=nothing}}, from_var_name = &quot;alice_x&quot;, to = Main.MyAgentType{name=alice1, uuid=b0dd07be, parent=Main.MyAgentType{name=alice, uuid=19c4439c, parent=FreeAgent{name=joint system, uuid=26bc8fb5, parent=nothing}}}, to_var_name = &quot;alice1_x&quot;)</code></pre><pre><code class="language-julia hljs">get_wires_to(alice1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1-element Vector{NamedTuple{(:from, :from_var_name, :to, :to_var_name), &lt;:Tuple{AbstractAlgebraicAgent, Any, AbstractAlgebraicAgent, Any}}}:
 (from = Main.MyAgentType{name=alice, uuid=19c4439c, parent=FreeAgent{name=joint system, uuid=26bc8fb5, parent=nothing}}, from_var_name = &quot;alice_x&quot;, to = Main.MyAgentType{name=alice1, uuid=b0dd07be, parent=Main.MyAgentType{name=alice, uuid=19c4439c, parent=FreeAgent{name=joint system, uuid=26bc8fb5, parent=nothing}}}, to_var_name = &quot;alice1_x&quot;)</code></pre><p>All the wires within an hierarchy can be retrieved as follows:</p><pre><code class="language-julia hljs">getopera(joint_system).wires</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{NamedTuple{(:from, :from_var_name, :to, :to_var_name), &lt;:Tuple{AbstractAlgebraicAgent, Any, AbstractAlgebraicAgent, Any}}}:
 (from = Main.MyAgentType{name=alice, uuid=19c4439c, parent=FreeAgent{name=joint system, uuid=26bc8fb5, parent=nothing}}, from_var_name = &quot;alice_x&quot;, to = Main.MyAgentType{name=bob, uuid=97c56935, parent=FreeAgent{name=joint system, uuid=26bc8fb5, parent=nothing}}, to_var_name = &quot;bob_x&quot;)
 (from = Main.MyAgentType{name=bob, uuid=97c56935, parent=FreeAgent{name=joint system, uuid=26bc8fb5, parent=nothing}}, from_var_name = &quot;bob_y&quot;, to = Main.MyAgentType{name=alice, uuid=19c4439c, parent=FreeAgent{name=joint system, uuid=26bc8fb5, parent=nothing}}, to_var_name = &quot;alice_y&quot;)
 (from = Main.MyAgentType{name=alice, uuid=19c4439c, parent=FreeAgent{name=joint system, uuid=26bc8fb5, parent=nothing}}, from_var_name = &quot;alice_x&quot;, to = Main.MyAgentType{name=alice1, uuid=b0dd07be, parent=Main.MyAgentType{name=alice, uuid=19c4439c, parent=FreeAgent{name=joint system, uuid=26bc8fb5, parent=nothing}}}, to_var_name = &quot;alice1_x&quot;)
 (from = Main.MyAgentType{name=bob, uuid=97c56935, parent=FreeAgent{name=joint system, uuid=26bc8fb5, parent=nothing}}, from_var_name = &quot;bob_x&quot;, to = Main.MyAgentType{name=bob1, uuid=6093063d, parent=Main.MyAgentType{name=bob, uuid=97c56935, parent=FreeAgent{name=joint system, uuid=26bc8fb5, parent=nothing}}}, to_var_name = &quot;bob1_x&quot;)</code></pre><p>Given an agent, if <a href="index.html#AlgebraicAgents.getobservable"><code>getobservable</code></a> is implemented for all agents that feed information into the specific agent, we can fetch the values incoming to it.</p><pre><code class="language-julia hljs">AlgebraicAgents.getobservable(a::MyAgentType, args...) = getname(a)

retrieve_input_vars(alice1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{String, String} with 1 entry:
  &quot;alice1_x&quot; =&gt; &quot;alice&quot;</code></pre><p>Additionally, we can plot the agents in the hierarchy, displaying the links between parents and children, along with the wires. The output can be adjusted as needed. Note that it is also possible to export an agent hierarchy as a Mermaid diagram. See <a href="index.html#AlgebraicAgents.typetree_mmd"><code>typetree_mmd</code></a> and <a href="index.html#AlgebraicAgents.agent_hierarchy_mmd"><code>agent_hierarchy_mmd</code></a>.</p><p>In what follows, <a href="index.html#AlgebraicAgents.wiring_diagram"><code>wiring_diagram</code></a> generates a visually appealing Graphviz diagram.</p><pre><code class="language-julia hljs">graph1 = wiring_diagram(joint_system)

run_graphviz(&quot;gv3.svg&quot;, graph1)</code></pre><p><img src="gv3.svg" alt/></p><pre><code class="language-julia hljs"># Do not show edges between parents and children.
graph2 = wiring_diagram(joint_system; parentship_edges=false)

run_graphviz(&quot;gv4.svg&quot;, graph2)</code></pre><p><img src="gv4.svg" alt/></p><pre><code class="language-julia hljs"># Only show listed agents.
graph3 = wiring_diagram([alice, alice1, bob, bob1])

run_graphviz(&quot;gv5.svg&quot;, graph3)</code></pre><p><img src="gv5.svg" alt/></p><pre><code class="language-julia hljs"># Group agents into two clusters.
graph4 = wiring_diagram([[alice, alice1], [bob, bob1]])

run_graphviz(&quot;gv4.svg&quot;, graph4)</code></pre><p><img src="gv4.svg" alt/></p><pre><code class="language-julia hljs"># Provide labels for clusters.
graph5 = wiring_diagram([[alice, alice1], [bob, bob1]]; group_labels=[&quot;alice&quot;, &quot;bob&quot;], parentship_edges=false)

run_graphviz(&quot;gv5.svg&quot;, graph5)</code></pre><p><img src="gv5.svg" alt/></p></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Wednesday 20 August 2025 04:19">Wednesday 20 August 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
