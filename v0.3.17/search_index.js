var documenterSearchIndex = {"docs":
[{"location":"sketches/algebraicdynamics/algebraicdynamics.html","page":"Lotka-Voltera Two Ways","title":"Lotka-Voltera Two Ways","text":"EditURL = \"https://github.com/Merck/AlgebraicAgents.jl/blob/main/tutorials/algebraicdynamics/algebraicdynamics.jl\"","category":"page"},{"location":"sketches/algebraicdynamics/algebraicdynamics.html#Lotka-Voltera-Two-Ways","page":"Lotka-Voltera Two Ways","title":"Lotka-Voltera Two Ways","text":"","category":"section"},{"location":"sketches/algebraicdynamics/algebraicdynamics.html","page":"Lotka-Voltera Two Ways","title":"Lotka-Voltera Two Ways","text":"We demonstrate an integration of AlgebraicDynamics.jl.","category":"page"},{"location":"sketches/algebraicdynamics/algebraicdynamics.html","page":"Lotka-Voltera Two Ways","title":"Lotka-Voltera Two Ways","text":"The tutorial is based on AlgebraicDynamics.jl: Lotka-Volterra Three Ways.","category":"page"},{"location":"sketches/algebraicdynamics/algebraicdynamics.html#Undirected-Composition","page":"Lotka-Voltera Two Ways","title":"Undirected Composition","text":"","category":"section"},{"location":"sketches/algebraicdynamics/algebraicdynamics.html","page":"Lotka-Voltera Two Ways","title":"Lotka-Voltera Two Ways","text":"using AlgebraicDynamics\nusing AlgebraicDynamics.UWDDynam\nusing Catlab.WiringDiagrams, Catlab.Programs\nusing LabelledArrays\nusing Plots\n\nconst UWD = UndirectedWiringDiagram","category":"page"},{"location":"sketches/algebraicdynamics/algebraicdynamics.html","page":"Lotka-Voltera Two Ways","title":"Lotka-Voltera Two Ways","text":"using AlgebraicAgents","category":"page"},{"location":"sketches/algebraicdynamics/algebraicdynamics.html","page":"Lotka-Voltera Two Ways","title":"Lotka-Voltera Two Ways","text":"Define the primitive systems","category":"page"},{"location":"sketches/algebraicdynamics/algebraicdynamics.html","page":"Lotka-Voltera Two Ways","title":"Lotka-Voltera Two Ways","text":"dotr(u,p,t) = p.α*u\ndotrf(u,p,t) = [-p.β*u[1]*u[2], p.γ*u[1]*u[2]]\ndotf(u,p,t) = -p.δ*u\n\nrabbit_growth = wrap_system(\"rabbit_growth\", ContinuousResourceSharer{Float64}(1, dotr))\nrabbitfox_predation = wrap_system(\"rabbitfox_predation\", ContinuousResourceSharer{Float64}(2, dotrf))\nfox_decline = wrap_system(\"fox_decline\", ContinuousResourceSharer{Float64}(1, dotf))","category":"page"},{"location":"sketches/algebraicdynamics/algebraicdynamics.html","page":"Lotka-Voltera Two Ways","title":"Lotka-Voltera Two Ways","text":"Define the composition pattern","category":"page"},{"location":"sketches/algebraicdynamics/algebraicdynamics.html","page":"Lotka-Voltera Two Ways","title":"Lotka-Voltera Two Ways","text":"rf = @relation (rabbits,foxes) begin\n    growth(rabbits)\n    predation(rabbits,foxes)\n    decline(foxes)\nend","category":"page"},{"location":"sketches/algebraicdynamics/algebraicdynamics.html","page":"Lotka-Voltera Two Ways","title":"Lotka-Voltera Two Ways","text":"Compose","category":"page"},{"location":"sketches/algebraicdynamics/algebraicdynamics.html","page":"Lotka-Voltera Two Ways","title":"Lotka-Voltera Two Ways","text":"rabbitfox_system = ⊕(rabbit_growth, rabbitfox_predation, fox_decline, diagram=rf, name=\"rabbitfox_system\")","category":"page"},{"location":"sketches/algebraicdynamics/algebraicdynamics.html","page":"Lotka-Voltera Two Ways","title":"Lotka-Voltera Two Ways","text":"Solve and plot","category":"page"},{"location":"sketches/algebraicdynamics/algebraicdynamics.html","page":"Lotka-Voltera Two Ways","title":"Lotka-Voltera Two Ways","text":"u0 = [10.0, 100.0]\nparams = LVector(α=.3, β=0.015, γ=0.015, δ=0.7)\ntspan = (0.0, 100.0)","category":"page"},{"location":"sketches/algebraicdynamics/algebraicdynamics.html","page":"Lotka-Voltera Two Ways","title":"Lotka-Voltera Two Ways","text":"import DifferentialEquations\nprob = DiffEqAgent(rabbitfox_system, u0, tspan, params)","category":"page"},{"location":"sketches/algebraicdynamics/algebraicdynamics.html","page":"Lotka-Voltera Two Ways","title":"Lotka-Voltera Two Ways","text":"sol = simulate(prob)","category":"page"},{"location":"sketches/algebraicdynamics/algebraicdynamics.html","page":"Lotka-Voltera Two Ways","title":"Lotka-Voltera Two Ways","text":"draw(sol; label=[\"rabbits\" \"foxes\"])","category":"page"},{"location":"sketches/algebraicdynamics/algebraicdynamics.html#Directed-Composition","page":"Lotka-Voltera Two Ways","title":"Directed Composition","text":"","category":"section"},{"location":"sketches/algebraicdynamics/algebraicdynamics.html","page":"Lotka-Voltera Two Ways","title":"Lotka-Voltera Two Ways","text":"using AlgebraicDynamics, AlgebraicDynamics.DWDDynam\nusing Catlab.WiringDiagrams, Catlab.Programs\nusing LabelledArrays\nusing Plots","category":"page"},{"location":"sketches/algebraicdynamics/algebraicdynamics.html","page":"Lotka-Voltera Two Ways","title":"Lotka-Voltera Two Ways","text":"using AlgebraicAgents, DifferentialEquations","category":"page"},{"location":"sketches/algebraicdynamics/algebraicdynamics.html","page":"Lotka-Voltera Two Ways","title":"Lotka-Voltera Two Ways","text":"Define the primitive systems","category":"page"},{"location":"sketches/algebraicdynamics/algebraicdynamics.html","page":"Lotka-Voltera Two Ways","title":"Lotka-Voltera Two Ways","text":"dotr(u, x, p, t) = [p.α*u[1] - p.β*u[1]*x[1]]\ndotf(u, x, p, t) = [p.γ*u[1]*x[1] - p.δ*u[1]]\n\nrabbit = wrap_system(\"rabbit\", ContinuousMachine{Float64}(1,1,1, dotr, (u, p, t) -> u))\nfox    = wrap_system(\"fox\", ContinuousMachine{Float64}(1,1,1, dotf, (u, p, t) -> u))","category":"page"},{"location":"sketches/algebraicdynamics/algebraicdynamics.html","page":"Lotka-Voltera Two Ways","title":"Lotka-Voltera Two Ways","text":"Define the composition pattern","category":"page"},{"location":"sketches/algebraicdynamics/algebraicdynamics.html","page":"Lotka-Voltera Two Ways","title":"Lotka-Voltera Two Ways","text":"rabbitfox_pattern = WiringDiagram([], [:rabbits, :foxes])\nrabbit_box = add_box!(rabbitfox_pattern, Box(:rabbit, [:pop], [:pop]))\nfox_box = add_box!(rabbitfox_pattern, Box(:fox, [:pop], [:pop]))\n\nadd_wires!(rabbitfox_pattern, Pair[\n    (rabbit_box, 1) => (fox_box, 1),\n    (fox_box, 1)    => (rabbit_box, 1),\n    (rabbit_box, 1) => (output_id(rabbitfox_pattern), 1),\n    (fox_box, 1)    => (output_id(rabbitfox_pattern), 2)\n])","category":"page"},{"location":"sketches/algebraicdynamics/algebraicdynamics.html","page":"Lotka-Voltera Two Ways","title":"Lotka-Voltera Two Ways","text":"Compose","category":"page"},{"location":"sketches/algebraicdynamics/algebraicdynamics.html","page":"Lotka-Voltera Two Ways","title":"Lotka-Voltera Two Ways","text":"rabbitfox_system = ⊕(rabbit, fox; diagram=rabbitfox_pattern, name=\"rabbitfox_system\")","category":"page"},{"location":"sketches/algebraicdynamics/algebraicdynamics.html","page":"Lotka-Voltera Two Ways","title":"Lotka-Voltera Two Ways","text":"Solve and plot","category":"page"},{"location":"sketches/algebraicdynamics/algebraicdynamics.html","page":"Lotka-Voltera Two Ways","title":"Lotka-Voltera Two Ways","text":"u0 = [10.0, 100.0]\nparams = LVector(α=.3, β=0.015, γ=0.015, δ=0.7)\ntspan = (0.0, 100.0)","category":"page"},{"location":"sketches/algebraicdynamics/algebraicdynamics.html","page":"Lotka-Voltera Two Ways","title":"Lotka-Voltera Two Ways","text":"# convert the system to a problem\nprob = DiffEqAgent(rabbitfox_system, u0, tspan, params)","category":"page"},{"location":"sketches/algebraicdynamics/algebraicdynamics.html","page":"Lotka-Voltera Two Ways","title":"Lotka-Voltera Two Ways","text":"# solve the problem\nsimulate(prob)","category":"page"},{"location":"sketches/algebraicdynamics/algebraicdynamics.html","page":"Lotka-Voltera Two Ways","title":"Lotka-Voltera Two Ways","text":"# plot\ndraw(prob; label=[\"rabbits\" \"foxes\"])","category":"page"},{"location":"sketches/algebraicdynamics/algebraicdynamics.html#Open-CPG","page":"Lotka-Voltera Two Ways","title":"Open CPG","text":"","category":"section"},{"location":"sketches/algebraicdynamics/algebraicdynamics.html","page":"Lotka-Voltera Two Ways","title":"Lotka-Voltera Two Ways","text":"using AlgebraicDynamics.CPortGraphDynam\nusing AlgebraicDynamics.CPortGraphDynam: barbell","category":"page"},{"location":"sketches/algebraicdynamics/algebraicdynamics.html","page":"Lotka-Voltera Two Ways","title":"Lotka-Voltera Two Ways","text":"Define the composition pattern","category":"page"},{"location":"sketches/algebraicdynamics/algebraicdynamics.html","page":"Lotka-Voltera Two Ways","title":"Lotka-Voltera Two Ways","text":"rabbitfox_pattern = barbell(1)\n\nrabbitfox_system = ⊕(rabbit, fox; diagram=rabbitfox_pattern, name=\"rabbitfox_system\")","category":"page"},{"location":"sketches/algebraicdynamics/algebraicdynamics.html","page":"Lotka-Voltera Two Ways","title":"Lotka-Voltera Two Ways","text":"Solve and plot","category":"page"},{"location":"sketches/algebraicdynamics/algebraicdynamics.html","page":"Lotka-Voltera Two Ways","title":"Lotka-Voltera Two Ways","text":"u0 = [10.0, 100.0]\nparams = LVector(α=.3, β=0.015, γ=0.015, δ=0.7)\ntspan = (0.0, 100.0)","category":"page"},{"location":"sketches/algebraicdynamics/algebraicdynamics.html","page":"Lotka-Voltera Two Ways","title":"Lotka-Voltera Two Ways","text":"# convert the system to a problem\nprob = DiffEqAgent(rabbitfox_system, u0, tspan, params)","category":"page"},{"location":"sketches/algebraicdynamics/algebraicdynamics.html","page":"Lotka-Voltera Two Ways","title":"Lotka-Voltera Two Ways","text":"# solve the problem\nsimulate(prob)","category":"page"},{"location":"sketches/algebraicdynamics/algebraicdynamics.html","page":"Lotka-Voltera Two Ways","title":"Lotka-Voltera Two Ways","text":"# plot\ndraw(prob; label=[\"rabbits\" \"foxes\"])","category":"page"},{"location":"design.html","page":"Framework design","title":"Framework design","text":"<script type=\"module\">\n  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@9/dist/mermaid.esm.min.mjs';\n  mermaid.initialize({ startOnLoad: true });\n</script>","category":"page"},{"location":"design.html","page":"Framework design","title":"Framework design","text":"<script type=\"module\">\n  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@9/dist/mermaid.esm.min.mjs';\n  mermaid.initialize({ startOnLoad: true });\n</script>","category":"page"},{"location":"design.html#Framework-design","page":"Framework design","title":"Framework design","text":"","category":"section"},{"location":"design.html","page":"Framework design","title":"Framework design","text":"Here we describe the design principles of the AlgebraicAgents. It should be of most use to advanced users and persons interested in contributing to the software. New users are encouraged to start by reading one of the tutorials (\"sketches\").","category":"page"},{"location":"design.html#Simulation-loop","page":"Framework design","title":"Simulation loop","text":"","category":"section"},{"location":"design.html","page":"Framework design","title":"Framework design","text":"We describe here the main simulation loop which steps models built in AlgebraicAgents forward in time.","category":"page"},{"location":"design.html","page":"Framework design","title":"Framework design","text":"AlgebraicAgents keeps agents synchronized by ensuring that the model will only simulate the agent(s) whose projected time (e.g. the maximum time for which that agent's trajectory has been solved) is the minimum of all agents. For example, if there are 3 agents, whose internal step sizes are of 1, 1.5, and 3 time units, respectively, then at the end of the first step, their projected time will be 1, 1.5, and 3 (assuming they all start at time 0). The simulation will find the minimum of those times and only simulate the agent(s) whose projected time(s) are equal to the minimum. In this case, it is the first agent, who is now projected to time 2 on the second step (other agents are not simulated). Now, the new minimum time is 1.5, and the second agent is projected to time 3 on the third step, etc. The simulation continues until all agents have been projected to their final time point, or the minimum of projected times reaches a maximum time horizon. If all agents take time steps of the same size, then they will all be updated each global step.","category":"page"},{"location":"design.html","page":"Framework design","title":"Framework design","text":"There are several functions in the interface for an AbstractAlgebraicAgent which implement these dynamics. When defining new agent types, one should implement the AlgebraicAgents._step! method, which will step that agent forward if its projected time is equal to the least projected time, among all agents in the hierarchy. Agent types also need to implement AlgebraicAgents._projected_to, which is crucial to keeping the simulation synchronized. It will return:","category":"page"},{"location":"design.html","page":"Framework design","title":"Framework design","text":"nothing if the agent does not implement its own _step! rule (e.g. FreeAgent which is a container of agents)\ntrue if the agent has been projected to the final time point (_step! will not be called again)\na value of Number, giving the time point to which the agent has been projected","category":"page"},{"location":"design.html","page":"Framework design","title":"Framework design","text":"These are collected into ret, which is an object that will be true if and only if all agents have returned true, and is otherwise the minimum of the numeric values (projection times) returned from each inner agent's step.","category":"page"},{"location":"design.html","page":"Framework design","title":"Framework design","text":"<div class=\"mermaid\">\n\nflowchart TD\n\n    Start((Enter Program))-->Project[Set t equal to minimum \\n projected time]:::GreenNode\n\n    Project-->RootDecision1{is root?}:::YellowNode\n    \n    RootDecision1 -->|yes| PreWalk[Prestep inner agents]:::GreenNode\n\n    RootDecision1 -->|no| Step[Step inner agents]:::GreenNode\n\n    PreWalk -.->|_prestep!| Inners([<:AbstractAlgebraicAgent]):::RedNode\n    \n    PreWalk --> Step\n\n    Step -.->|step!| Inners\n\n    subgraph inners\n    Inners\n    end\n\n    Ret([ret]):::RedNode\n\n    Inners -.->|_projected_to| Ret\n\n    Step --> LocalDecision{local projected time == t\\n equals the min projected time}:::YellowNode\n\n    LocalDecision -->|yes| LocalStep[Local step]:::GreenNode\n    LocalDecision -->|no| RootDecision2{is root?}:::YellowNode\n\n    LocalStep -.->|_projected_to| Ret\n\n    LocalStep --> RootDecision2\n\n    subgraph Opera\n\n    RootDecision2 -->|yes| InstantOpera[Execute instantaneous interactions]:::GreenNode\n    InstantOpera --> FutureOpera[Execute delayed interactions]:::GreenNode\n    FutureOpera --> ControlOpera[Execute control interactions]:::GreenNode\n    end\n\n    Opera -.->|_projected_to| Ret\n\n    RootDecision2 -->|no| Stop\n\n    ControlOpera --> Stop((Exit program and\\n return ret))\n\n    classDef GreenNode fill:#D5E8D4,stroke:#82B366;\n    classDef RedNode fill:#F8CECC,stroke:#B85450;\n    classDef YellowNode fill:#FFE6CC,stroke:#D79B00;\n\n</div>","category":"page"},{"location":"design.html","page":"Framework design","title":"Framework design","text":"Above we show a caricature of the main simulation loop. \"Enter program\" corresponds to the call to simulate, the value of ret is (typically) initialized to 0.0. The simulation continues to step while ret is not true (meaning the maximum time horizon has been reached by the slowest agent), or has not exceeded some maximum. ","category":"page"},{"location":"design.html","page":"Framework design","title":"Framework design","text":"The inner area enclosed by a dashed border represents where program control is given to the step! method. The root agent applies _prestep! recurvisely to all of its inner (enclosed) agents. After this, step! is then applied to all inner agents, and ret is updated by each of them. Then the agent applies its own local update _step! if its own projected time is equal to the minimum of all inner agent projected times (not shown). Then the Opera module for additional interactions is called for the root agent.","category":"page"},{"location":"design.html#Opera","page":"Framework design","title":"Opera","text":"","category":"section"},{"location":"design.html","page":"Framework design","title":"Framework design","text":"The Opera system allows interactions between agents to be scheduled. By default, AlgebraicAgents.jl provides support for three types of interactions:","category":"page"},{"location":"design.html","page":"Framework design","title":"Framework design","text":"futures (delayed interactions)\nsystem controls\ninstantious interactions","category":"page"},{"location":"design.html","page":"Framework design","title":"Framework design","text":"For more details, see the API documentation of Opera and our tests.","category":"page"},{"location":"design.html#Futures","page":"Framework design","title":"Futures","text":"","category":"section"},{"location":"design.html","page":"Framework design","title":"Framework design","text":"You may schedule function calls, to be executed at predetermined points of time. An action is modeled as a tuple (id, call, time), where id is an optional textual identifier of the action and call is a (parameterless) anonymous function, which will be called at the given time. Once the action is executed, the return value with corresponding action id and execution time is added to futures_log field of Opera instance.","category":"page"},{"location":"design.html","page":"Framework design","title":"Framework design","text":"See add_future! and @future.","category":"page"},{"location":"design.html#Example","page":"Framework design","title":"Example","text":"","category":"section"},{"location":"design.html","page":"Framework design","title":"Framework design","text":"alice = MyAgentType(\"alice\")\ninteract = agent -> wake_up!(agent)\n@future alice 5.0 interact(alice) \"alice_schedule\"","category":"page"},{"location":"design.html","page":"Framework design","title":"Framework design","text":"The solver will stop at t=5 and call the function () -> interact(alice) (a closure is taken at the time when @future is invoked). This interaction is identified as \"alice_schedule\".","category":"page"},{"location":"design.html#Control-Interactions","page":"Framework design","title":"Control Interactions","text":"","category":"section"},{"location":"design.html","page":"Framework design","title":"Framework design","text":"You may schedule control function calls, to be executed at every step of the model. An action is modeled as a tuple (id, call), where id is an optional textual identifier of the action, and call is a (parameterless) anonymous function. Once the action is executed, the return value with corresponding action id and execution time is added to controls_log field of Opera instance.","category":"page"},{"location":"design.html","page":"Framework design","title":"Framework design","text":"See add_control! and @control.","category":"page"},{"location":"design.html#Example-2","page":"Framework design","title":"Example","text":"","category":"section"},{"location":"design.html","page":"Framework design","title":"Framework design","text":"system = MyAgentType(\"system\")\ncontrol = agent -> agent.temp > 100 && cool!(agent)\n@control system control(system) \"temperature control\"","category":"page"},{"location":"design.html","page":"Framework design","title":"Framework design","text":"At each step, the solver will call the function () -> control(system) (a closure is taken at the time when @future is invoked).","category":"page"},{"location":"design.html#Instantious-Interactions","page":"Framework design","title":"Instantious Interactions","text":"","category":"section"},{"location":"design.html","page":"Framework design","title":"Framework design","text":"You may schedule additional interactions which exist within a single step of the model; such actions are modeled as named tuples (id, priority=0., call). Here, call is a (parameterless) anonymous function.","category":"page"},{"location":"design.html","page":"Framework design","title":"Framework design","text":"They exist within a single step of the model and are executed after the calls to _prestep! and _step! finish, in the order of the assigned priorities.","category":"page"},{"location":"design.html","page":"Framework design","title":"Framework design","text":"In particular, you may schedule interactions of two kinds:","category":"page"},{"location":"design.html","page":"Framework design","title":"Framework design","text":"poke(agent, priority), which will translate into a call () -> _interact!(agent), with the specified priority,\n@call opera expresion priority, which will translate into a call () -> expression, with the specified priority.","category":"page"},{"location":"design.html","page":"Framework design","title":"Framework design","text":"See poke and @call.","category":"page"},{"location":"design.html#Examples","page":"Framework design","title":"Examples","text":"","category":"section"},{"location":"design.html","page":"Framework design","title":"Framework design","text":"# `poke`\npoke(agent, 1.) # call `_interact!(agent)`; this call is added to the instantious priority queue with priority 1","category":"page"},{"location":"design.html","page":"Framework design","title":"Framework design","text":"# `@call`\nbob_agent = only(getagent(agent, r\"bob\"))\n@call agent wake_up(bob_agent) # translates into `() -> wake_up(bob_agent)` with priority 0","category":"page"},{"location":"design_mmd.html","page":"Framework design","title":"Framework design","text":"<script type=\"module\">\n  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@9/dist/mermaid.esm.min.mjs';\n  mermaid.initialize({ startOnLoad: true });\n</script>","category":"page"},{"location":"design_mmd.html","page":"Framework design","title":"Framework design","text":"<script type=\"module\">\n  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@9/dist/mermaid.esm.min.mjs';\n  mermaid.initialize({ startOnLoad: true });\n</script>","category":"page"},{"location":"design_mmd.html","page":"Framework design","title":"Framework design","text":"<script type=\"module\">\n  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@9/dist/mermaid.esm.min.mjs';\n  mermaid.initialize({ startOnLoad: true });\n</script>","category":"page"},{"location":"design_mmd.html#Framework-design","page":"Framework design","title":"Framework design","text":"","category":"section"},{"location":"design_mmd.html","page":"Framework design","title":"Framework design","text":"Here we describe the design principles of the AlgebraicAgents. It should be of most use to advanced users and persons interested in contributing to the software. New users are encouraged to start by reading one of the tutorials (\"sketches\").","category":"page"},{"location":"design_mmd.html#Simulation-loop","page":"Framework design","title":"Simulation loop","text":"","category":"section"},{"location":"design_mmd.html","page":"Framework design","title":"Framework design","text":"We describe here the main simulation loop which steps models built in AlgebraicAgents forward in time.","category":"page"},{"location":"design_mmd.html","page":"Framework design","title":"Framework design","text":"AlgebraicAgents keeps agents synchronized by ensuring that the model will only simulate the agent(s) whose projected time (e.g. the maximum time for which that agent's trajectory has been solved) is the minimum of all agents. For example, if there are 3 agents, whose internal step sizes are of 1, 1.5, and 3 time units, respectively, then at the end of the first step, their projected time will be 1, 1.5, and 3 (assuming they all start at time 0). The simulation will find the minimum of those times and only simulate the agent(s) whose projected time(s) are equal to the minimum. In this case, it is the first agent, who is now projected to time 2 on the second step (other agents are not simulated). Now, the new minimum time is 1.5, and the second agent is projected to time 3 on the third step, etc. The simulation continues until all agents have been projected to their final time point, or the minimum of projected times reaches a maximum time horizon. If all agents take time steps of the same size, then they will all be updated each global step.","category":"page"},{"location":"design_mmd.html","page":"Framework design","title":"Framework design","text":"There are several functions in the interface for an AbstractAlgebraicAgent which implement these dynamics. When defining new agent types, one should implement the AlgebraicAgents._step! method, which will step that agent forward if its projected time is equal to the least projected time, among all agents in the hierarchy. Agent types also need to implement AlgebraicAgents._projected_to, which is crucial to keeping the simulation synchronized. It will return:","category":"page"},{"location":"design_mmd.html","page":"Framework design","title":"Framework design","text":"nothing if the agent does not implement its own _step! rule (e.g. FreeAgent which is a container of agents)\ntrue if the agent has been projected to the final time point (_step! will not be called again)\na value of Number, giving the time point to which the agent has been projected","category":"page"},{"location":"design_mmd.html","page":"Framework design","title":"Framework design","text":"These are collected into ret, which is an object that will be true if and only if all agents have returned true, and is otherwise the minimum of the numeric values (projection times) returned from each inner agent's step.","category":"page"},{"location":"design_mmd.html","page":"Framework design","title":"Framework design","text":"<div class=\"mermaid\">\n\nflowchart TD\n\n    Start((Enter Program))-->Project[Set t equal to minimum \\n projected time]:::GreenNode\n\n    Project-->RootDecision1{is root?}:::YellowNode\n    \n    RootDecision1 -->|yes| PreWalk[Prestep inner agents]:::GreenNode\n\n    RootDecision1 -->|no| Step[Step inner agents]:::GreenNode\n\n    PreWalk -.->|_prestep!| Inners([<:AbstractAlgebraicAgent]):::RedNode\n    \n    PreWalk --> Step\n\n    Step -.->|step!| Inners\n\n    subgraph inners\n    Inners\n    end\n\n    Ret([ret]):::RedNode\n\n    Inners -.->|_projected_to| Ret\n\n    Step --> LocalDecision{local projected time == t\\n equals the min projected time}:::YellowNode\n\n    LocalDecision -->|yes| LocalStep[Local step]:::GreenNode\n    LocalDecision -->|no| RootDecision2{is root?}:::YellowNode\n\n    LocalStep -.->|_projected_to| Ret\n\n    LocalStep --> RootDecision2\n\n    subgraph Opera\n\n    RootDecision2 -->|yes| InstantOpera[Execute instantaneous interactions]:::GreenNode\n    InstantOpera --> FutureOpera[Execute delayed interactions]:::GreenNode\n    FutureOpera --> ControlOpera[Execute control interactions]:::GreenNode\n    end\n\n    Opera -.->|_projected_to| Ret\n\n    RootDecision2 -->|no| Stop\n\n    ControlOpera --> Stop((Exit program and\\n return ret))\n\n    classDef GreenNode fill:#D5E8D4,stroke:#82B366;\n    classDef RedNode fill:#F8CECC,stroke:#B85450;\n    classDef YellowNode fill:#FFE6CC,stroke:#D79B00;\n\n</div>","category":"page"},{"location":"design_mmd.html","page":"Framework design","title":"Framework design","text":"Above we show a caricature of the main simulation loop. \"Enter program\" corresponds to the call to simulate, the value of ret is (typically) initialized to 0.0. The simulation continues to step while ret is not true (meaning the maximum time horizon has been reached by the slowest agent), or has not exceeded some maximum. ","category":"page"},{"location":"design_mmd.html","page":"Framework design","title":"Framework design","text":"The inner area enclosed by a dashed border represents where program control is given to the step! method. The root agent applies _prestep! recurvisely to all of its inner (enclosed) agents. After this, step! is then applied to all inner agents, and ret is updated by each of them. Then the agent applies its own local update _step! if its own projected time is equal to the minimum of all inner agent projected times (not shown). Then the Opera module for additional interactions is called for the root agent.","category":"page"},{"location":"design_mmd.html#Opera","page":"Framework design","title":"Opera","text":"","category":"section"},{"location":"design_mmd.html","page":"Framework design","title":"Framework design","text":"The Opera system allows interactions between agents to be scheduled. By default, AlgebraicAgents.jl provides support for three types of interactions:","category":"page"},{"location":"design_mmd.html","page":"Framework design","title":"Framework design","text":"futures (delayed interactions)\nsystem controls\ninstantious interactions","category":"page"},{"location":"design_mmd.html","page":"Framework design","title":"Framework design","text":"For more details, see the API documentation of Opera and our tests.","category":"page"},{"location":"design_mmd.html#Futures","page":"Framework design","title":"Futures","text":"","category":"section"},{"location":"design_mmd.html","page":"Framework design","title":"Framework design","text":"You may schedule function calls, to be executed at predetermined points of time. An action is modeled as a tuple (id, call, time), where id is an optional textual identifier of the action and call is a (parameterless) anonymous function, which will be called at the given time. Once the action is executed, the return value with corresponding action id and execution time is added to futures_log field of Opera instance.","category":"page"},{"location":"design_mmd.html","page":"Framework design","title":"Framework design","text":"See add_future! and @future.","category":"page"},{"location":"design_mmd.html#Example","page":"Framework design","title":"Example","text":"","category":"section"},{"location":"design_mmd.html","page":"Framework design","title":"Framework design","text":"alice = MyAgentType(\"alice\")\ninteract = agent -> wake_up!(agent)\n@future alice 5.0 interact(alice) \"alice_schedule\"","category":"page"},{"location":"design_mmd.html","page":"Framework design","title":"Framework design","text":"The solver will stop at t=5 and call the function () -> interact(alice) (a closure is taken at the time when @future is invoked). This interaction is identified as \"alice_schedule\".","category":"page"},{"location":"design_mmd.html#Control-Interactions","page":"Framework design","title":"Control Interactions","text":"","category":"section"},{"location":"design_mmd.html","page":"Framework design","title":"Framework design","text":"You may schedule control function calls, to be executed at every step of the model. An action is modeled as a tuple (id, call), where id is an optional textual identifier of the action, and call is a (parameterless) anonymous function. Once the action is executed, the return value with corresponding action id and execution time is added to controls_log field of Opera instance.","category":"page"},{"location":"design_mmd.html","page":"Framework design","title":"Framework design","text":"See add_control! and @control.","category":"page"},{"location":"design_mmd.html#Example-2","page":"Framework design","title":"Example","text":"","category":"section"},{"location":"design_mmd.html","page":"Framework design","title":"Framework design","text":"system = MyAgentType(\"system\")\ncontrol = agent -> agent.temp > 100 && cool!(agent)\n@control system control(system) \"temperature control\"","category":"page"},{"location":"design_mmd.html","page":"Framework design","title":"Framework design","text":"At each step, the solver will call the function () -> control(system) (a closure is taken at the time when @future is invoked).","category":"page"},{"location":"design_mmd.html#Instantious-Interactions","page":"Framework design","title":"Instantious Interactions","text":"","category":"section"},{"location":"design_mmd.html","page":"Framework design","title":"Framework design","text":"You may schedule additional interactions which exist within a single step of the model; such actions are modeled as named tuples (id, priority=0., call). Here, call is a (parameterless) anonymous function.","category":"page"},{"location":"design_mmd.html","page":"Framework design","title":"Framework design","text":"They exist within a single step of the model and are executed after the calls to _prestep! and _step! finish, in the order of the assigned priorities.","category":"page"},{"location":"design_mmd.html","page":"Framework design","title":"Framework design","text":"In particular, you may schedule interactions of two kinds:","category":"page"},{"location":"design_mmd.html","page":"Framework design","title":"Framework design","text":"poke(agent, priority), which will translate into a call () -> _interact!(agent), with the specified priority,\n@call opera expresion priority, which will translate into a call () -> expression, with the specified priority.","category":"page"},{"location":"design_mmd.html","page":"Framework design","title":"Framework design","text":"See poke and @call.","category":"page"},{"location":"design_mmd.html#Examples","page":"Framework design","title":"Examples","text":"","category":"section"},{"location":"design_mmd.html","page":"Framework design","title":"Framework design","text":"# `poke`\npoke(agent, 1.) # call `_interact!(agent)`; this call is added to the instantious priority queue with priority 1","category":"page"},{"location":"design_mmd.html","page":"Framework design","title":"Framework design","text":"# `@call`\nbob_agent = only(getagent(agent, r\"bob\"))\n@call agent wake_up(bob_agent) # translates into `() -> wake_up(bob_agent)` with priority 0","category":"page"},{"location":"sketches/agents/agents.html","page":"Agents.jl Integration","title":"Agents.jl Integration","text":"EditURL = \"https://github.com/Merck/AlgebraicAgents.jl/blob/main/tutorials/agents/agents.jl\"","category":"page"},{"location":"sketches/agents/agents.html#Agents.jl-Integration","page":"Agents.jl Integration","title":"Agents.jl Integration","text":"","category":"section"},{"location":"sketches/agents/agents.html","page":"Agents.jl Integration","title":"Agents.jl Integration","text":"We instantiate an agent-based SIR model based on Agents.jl: SIR model for the spread of COVID-19 make use of a SIR model constructor from an Agents.jl' SIR model for the spread of COVID-19, and then we simulate the model using AlgebraicAgents.jl","category":"page"},{"location":"sketches/agents/agents.html#SIR-Model-in-Agents.jl","page":"Agents.jl Integration","title":"SIR Model in Agents.jl","text":"","category":"section"},{"location":"sketches/agents/agents.html","page":"Agents.jl Integration","title":"Agents.jl Integration","text":"To begin with, we define the Agents.jl model:","category":"page"},{"location":"sketches/agents/agents.html","page":"Agents.jl Integration","title":"Agents.jl Integration","text":"# SIR model for the spread of COVID-19\n# taken from https://juliadynamics.github.io/Agents.jl/stable/examples/sir/\nusing AlgebraicAgents\nusing Agents, Random\nusing Agents.DataFrames, Agents.Graphs\nusing Distributions: Poisson, DiscreteNonParametric\nusing DrWatson: @dict\nusing Plots\n\n@agent PoorSoul GraphAgent begin\n    days_infected::Int  ## number of days since is infected\n    status::Symbol  ## 1: S, 2: I, 3:R\nend","category":"page"},{"location":"sketches/agents/agents.html","page":"Agents.jl Integration","title":"Agents.jl Integration","text":"Let's provide the constructors:","category":"page"},{"location":"sketches/agents/agents.html","page":"Agents.jl Integration","title":"Agents.jl Integration","text":"function model_initiation(;\n                          Ns,\n                          migration_rates,\n                          β_und,\n                          β_det,\n                          infection_period = 30,\n                          reinfection_probability = 0.05,\n                          detection_time = 14,\n                          death_rate = 0.02,\n                          Is = [zeros(Int, length(Ns) - 1)..., 1],\n                          seed = 0)\n    rng = MersenneTwister(seed)\n    @assert length(Ns)==\n            length(Is)==\n            length(β_und)==\n            length(β_det)==\n            size(migration_rates, 1) \"length of Ns, Is, and B, and number of rows/columns in migration_rates should be the same \"\n    @assert size(migration_rates, 1)==size(migration_rates, 2) \"migration_rates rates should be a square matrix\"\n\n    C = length(Ns)\n    # normalize migration_rates\n    migration_rates_sum = sum(migration_rates, dims = 2)\n    for c in 1:C\n        migration_rates[c, :] ./= migration_rates_sum[c]\n    end\n\n    properties = @dict(Ns,\n                       Is,\n                       β_und,\n                       β_det,\n                       β_det,\n                       migration_rates,\n                       infection_period,\n                       infection_period,\n                       reinfection_probability,\n                       detection_time,\n                       C,\n                       death_rate)\n    space = GraphSpace(complete_digraph(C))\n    model = ABM(PoorSoul, space; properties, rng)\n\n    # Add initial individuals\n    for city in 1:C, n in 1:Ns[city]\n        ind = add_agent!(city, model, 0, :S) ## Susceptible\n    end\n    # add infected individuals\n    for city in 1:C\n        inds = ids_in_position(city, model)\n        for n in 1:Is[city]\n            agent = model[inds[n]]\n            agent.status = :I ## Infected\n            agent.days_infected = 1\n        end\n    end\n    return model\nend\n\nusing LinearAlgebra: diagind\n\nfunction create_params(;\n                       C,\n                       max_travel_rate,\n                       infection_period = 30,\n                       reinfection_probability = 0.05,\n                       detection_time = 14,\n                       death_rate = 0.02,\n                       Is = [zeros(Int, C - 1)..., 1],\n                       seed = 19)\n    Random.seed!(seed)\n    Ns = rand(50:5000, C)\n    β_und = rand(0.3:0.02:0.6, C)\n    β_det = β_und ./ 10\n\n    Random.seed!(seed)\n    migration_rates = zeros(C, C)\n    for c in 1:C\n        for c2 in 1:C\n            migration_rates[c, c2] = (Ns[c] + Ns[c2]) / Ns[c]\n        end\n    end\n    maxM = maximum(migration_rates)\n    migration_rates = (migration_rates .* max_travel_rate) ./ maxM\n    migration_rates[diagind(migration_rates)] .= 1.0\n\n    params = @dict(Ns,\n                   β_und,\n                   β_det,\n                   migration_rates,\n                   infection_period,\n                   reinfection_probability,\n                   detection_time,\n                   death_rate,\n                   Is)\n\n    return params\nend","category":"page"},{"location":"sketches/agents/agents.html","page":"Agents.jl Integration","title":"Agents.jl Integration","text":"It remains to provide the SIR stepping functions:","category":"page"},{"location":"sketches/agents/agents.html","page":"Agents.jl Integration","title":"Agents.jl Integration","text":"function agent_step!(agent, model)\n    @get_model model\n    extract_agent(model, agent)\n    migrate!(agent, model)\n    transmit!(agent, model)\n    update!(agent, model)\n    recover_or_die!(agent, model)\nend\n\nfunction migrate!(agent, model)\n    pid = agent.pos\n    d = DiscreteNonParametric(1:(model.C), model.migration_rates[pid, :])\n    m = rand(model.rng, d)\n    if m ≠ pid\n        move_agent!(agent, m, model)\n    end\nend\n\nfunction transmit!(agent, model)\n    agent.status == :S && return\n    rate = if agent.days_infected < model.detection_time\n        model.β_und[agent.pos]\n    else\n        model.β_det[agent.pos]\n    end\n\n    d = Poisson(rate)\n    n = rand(model.rng, d)\n    n == 0 && return\n\n    for contactID in ids_in_position(agent, model)\n        contact = model[contactID]\n        if contact.status == :S ||\n           (contact.status == :R && rand(model.rng) ≤ model.reinfection_probability)\n            contact.status = :I\n            n -= 1\n            n == 0 && return\n        end\n    end\nend\n\nupdate!(agent, model) = agent.status == :I && (agent.days_infected += 1)\n\nfunction recover_or_die!(agent, model)\n    if agent.days_infected ≥ model.infection_period\n        if rand(model.rng) ≤ model.death_rate\n            @a kill_agent!(agent, model)\n        else\n            agent.status = :R\n            agent.days_infected = 0\n        end\n    end\nend","category":"page"},{"location":"sketches/agents/agents.html","page":"Agents.jl Integration","title":"Agents.jl Integration","text":"That's it!","category":"page"},{"location":"sketches/agents/agents.html#Simulation-Using-AlgebraicAgents.jl","page":"Agents.jl Integration","title":"Simulation Using AlgebraicAgents.jl","text":"","category":"section"},{"location":"sketches/agents/agents.html","page":"Agents.jl Integration","title":"Agents.jl Integration","text":"We instantiate a sample ABM model:","category":"page"},{"location":"sketches/agents/agents.html","page":"Agents.jl Integration","title":"Agents.jl Integration","text":"# create a sample agent based model\nparams = create_params(C = 8, max_travel_rate = 0.01)\nabm = model_initiation(; params...)","category":"page"},{"location":"sketches/agents/agents.html","page":"Agents.jl Integration","title":"Agents.jl Integration","text":"Let's specify what data to collect:","category":"page"},{"location":"sketches/agents/agents.html","page":"Agents.jl Integration","title":"Agents.jl Integration","text":"infected(x) = count(i == :I for i in x)\nrecovered(x) = count(i == :R for i in x)\nto_collect = [(:status, f) for f in (infected, recovered, length)]","category":"page"},{"location":"sketches/agents/agents.html","page":"Agents.jl Integration","title":"Agents.jl Integration","text":"We wrap the model as an agent:","category":"page"},{"location":"sketches/agents/agents.html","page":"Agents.jl Integration","title":"Agents.jl Integration","text":"m = ABMAgent(\"sir_model\", abm; agent_step!, tspan=(0., 100.), adata=to_collect)","category":"page"},{"location":"sketches/agents/agents.html","page":"Agents.jl Integration","title":"Agents.jl Integration","text":"And we simulate the dynamics:","category":"page"},{"location":"sketches/agents/agents.html","page":"Agents.jl Integration","title":"Agents.jl Integration","text":"simulate(m)","category":"page"},{"location":"sketches/agents/agents.html","page":"Agents.jl Integration","title":"Agents.jl Integration","text":"draw(m)","category":"page"},{"location":"sketches/sciml/sciml.html","page":"SciML Integration","title":"SciML Integration","text":"EditURL = \"https://github.com/Merck/AlgebraicAgents.jl/blob/main/tutorials/sciml/sciml.jl\"","category":"page"},{"location":"sketches/sciml/sciml.html#SciML-Integration","page":"SciML Integration","title":"SciML Integration","text":"","category":"section"},{"location":"sketches/sciml/sciml.html","page":"SciML Integration","title":"SciML Integration","text":"using AlgebraicAgents","category":"page"},{"location":"sketches/sciml/sciml.html","page":"SciML Integration","title":"SciML Integration","text":"# declare problems (models in AA's type system)\nusing DifferentialEquations\n\n# vanilla function\nf(u,p,t) = 1.01*u\nu0 = 1/2\ntspan = (0.0,10.0)\nprob = ODEProblem(f,u0,tspan)","category":"page"},{"location":"sketches/sciml/sciml.html#Atomic-Models","page":"SciML Integration","title":"Atomic Models","text":"","category":"section"},{"location":"sketches/sciml/sciml.html","page":"SciML Integration","title":"SciML Integration","text":"m1 = DiffEqAgent(\"model1\", prob)\nm2 = DiffEqAgent(\"model2\", prob)\nm3 = DiffEqAgent(\"model3\", prob)\n\n# declare observables (out ports) for a model\n# it will be possible to reference m3's first variable as both `o1`, `o2`\npush!(observables(m3), \"o1\" => 1, \"o2\" => 1)\n\n# simple function, calls to which will be scheduled during the model integration\ncustom_function(agent, t) = println(\"inside $agent at time $t\")\n\n# a bit more intricate logic -\nfunction f_(u,p,t)\n    # access the wrapping agent (hierarchy bond)\n    agent = extract_agent(p)\n\n    # access observables\n    o1 = getobservable(getagent(agent, \"../model3\"), \"o1\")\n    o2 = getobservable(getagent(agent, \"../model3\"), \"o2\")\n    # fetch observable's value at **a given time point in the past**\n    o3 = gettimeobservable(getagent(agent, \"../model3\"), t/2, 1)\n\n    # schedule interaction\n    # first, schedule a call to `_interact!(agent)` with priority 0\n    # this is the default behavior\n    poke(agent)\n    # alternatively, provide a function call f(args...)\n    # this will be expanded to a call f(agent, args...)\n    @call agent custom_function(agent, t)\n\n    min(2., 1.01*u + o1 + o2 + o3)\nend","category":"page"},{"location":"sketches/sciml/sciml.html#Another-Atomic-Model","page":"SciML Integration","title":"Another Atomic Model","text":"","category":"section"},{"location":"sketches/sciml/sciml.html","page":"SciML Integration","title":"SciML Integration","text":"m4 = DiffEqAgent(\"model4\", ODEProblem(f_,u0,tspan))","category":"page"},{"location":"sketches/sciml/sciml.html#Hierarchical-Sum-of-Atomic-Models","page":"SciML Integration","title":"Hierarchical Sum of Atomic Models","text":"","category":"section"},{"location":"sketches/sciml/sciml.html","page":"SciML Integration","title":"SciML Integration","text":"m = ⊕(m1, m2; name=\"diagram1\") ⊕ ⊕(m3, m4; name=\"diagram2\")","category":"page"},{"location":"sketches/sciml/sciml.html","page":"SciML Integration","title":"SciML Integration","text":"# explore path-like structure of agents\n\n# index by unix-like path\ngetagent(m, \"diagram1/model1/\")\ngetagent(m, \"diagram1/model1\")\ngetagent(m1, \"../model2\")\ngetagent(m1, \"../../diagram2/model3\")\n\n# index by regex expression\ngetagent(m, r\"model.*\")\n\n# index by glob expression\ngetagent(m, glob\"**/model?/\")\ngetagent(m, glob\"**/model?\"s)","category":"page"},{"location":"sketches/sciml/sciml.html#Solving","page":"SciML Integration","title":"Solving","text":"","category":"section"},{"location":"sketches/sciml/sciml.html","page":"SciML Integration","title":"SciML Integration","text":"sol = simulate(m)","category":"page"},{"location":"sketches/stochastic_simulation/anderson.html","page":"Simulating Stochastic Reaction Systems","title":"Simulating Stochastic Reaction Systems","text":"EditURL = \"https://github.com/Merck/AlgebraicAgents.jl/blob/main/tutorials/stochastic_simulation/anderson.jl\"","category":"page"},{"location":"sketches/stochastic_simulation/anderson.html#Simulating-Stochastic-Reaction-Systems","page":"Simulating Stochastic Reaction Systems","title":"Simulating Stochastic Reaction Systems","text":"","category":"section"},{"location":"sketches/stochastic_simulation/anderson.html","page":"Simulating Stochastic Reaction Systems","title":"Simulating Stochastic Reaction Systems","text":"To demonstrate the generality of AlgebraicAgents.jl, we demonstrate here how to use the package to set up a type system capable of simulating continuous time discrete state stochastic processes using the method described by Anderson (2007).","category":"page"},{"location":"sketches/stochastic_simulation/anderson.html","page":"Simulating Stochastic Reaction Systems","title":"Simulating Stochastic Reaction Systems","text":"We begin by importing packages we will use.","category":"page"},{"location":"sketches/stochastic_simulation/anderson.html","page":"Simulating Stochastic Reaction Systems","title":"Simulating Stochastic Reaction Systems","text":"using AlgebraicAgents, Distributions, DataFrames, Plots","category":"page"},{"location":"sketches/stochastic_simulation/anderson.html#Reaction-System","page":"Simulating Stochastic Reaction Systems","title":"Reaction System","text":"","category":"section"},{"location":"sketches/stochastic_simulation/anderson.html","page":"Simulating Stochastic Reaction Systems","title":"Simulating Stochastic Reaction Systems","text":"We use the @aagent struct to define a new type which is a concrete subtype of AbstractAlgebraicAgent called ReactionSystem. It contains data members:","category":"page"},{"location":"sketches/stochastic_simulation/anderson.html","page":"Simulating Stochastic Reaction Systems","title":"Simulating Stochastic Reaction Systems","text":"t: current simulation time\nΔ: the interarrival time between events\nX: current system state\nX0: initial system state\ndf_output: a DataFrame contining the sampled trajectory","category":"page"},{"location":"sketches/stochastic_simulation/anderson.html","page":"Simulating Stochastic Reaction Systems","title":"Simulating Stochastic Reaction Systems","text":"@aagent struct ReactionSystem{T,S}\n    t::T\n    Δ::T\n    X::Vector{S}\n    X0::Vector{S}\n    df_output::DataFrame\nend","category":"page"},{"location":"sketches/stochastic_simulation/anderson.html","page":"Simulating Stochastic Reaction Systems","title":"Simulating Stochastic Reaction Systems","text":"We define a method make_reactionsystem which constructs a concrete instantiation of the ReactionSystem type, with a given name and initial state X0. Note that we use entangle! to add an instantiation of the FreeAgent type exported from AlgebraicAgents to the object. This agent is called \"clocks\" and will contain agents which jointly make up the stochastic dynamics of the system.","category":"page"},{"location":"sketches/stochastic_simulation/anderson.html","page":"Simulating Stochastic Reaction Systems","title":"Simulating Stochastic Reaction Systems","text":"function make_reactionsystem(name::T, X0::Vector{S}) where {T,S}\n    df_output = DataFrame(time=Float64[],clock=String[])\n    for i in eachindex(X0)\n        insertcols!(df_output, Symbol(\"X\"*string(i))=>S[])\n    end\n    rs = ReactionSystem{Float64,S}(name, 0.0, 0.0, X0, X0, df_output)\n    entangle!(rs, FreeAgent(\"clocks\"))\n    return rs\nend","category":"page"},{"location":"sketches/stochastic_simulation/anderson.html","page":"Simulating Stochastic Reaction Systems","title":"Simulating Stochastic Reaction Systems","text":"Because the ReactionSystem itself has no dynamics (it represents the \"world state\"), its implementation of AlgebraicAgents._step! does nothing.","category":"page"},{"location":"sketches/stochastic_simulation/anderson.html","page":"Simulating Stochastic Reaction Systems","title":"Simulating Stochastic Reaction Systems","text":"AlgebraicAgents._step!(a::ReactionSystem) = nothing","category":"page"},{"location":"sketches/stochastic_simulation/anderson.html","page":"Simulating Stochastic Reaction Systems","title":"Simulating Stochastic Reaction Systems","text":"We also need to implement AlgebraicAgents._projected_to for ReactionSystem. In this case because the times to which the system is solved are determined by the individual stochastic processes which make up the system (defined later), we can set it to the trivial implementation which does nothing.","category":"page"},{"location":"sketches/stochastic_simulation/anderson.html","page":"Simulating Stochastic Reaction Systems","title":"Simulating Stochastic Reaction Systems","text":"AlgebraicAgents._projected_to(a::ReactionSystem) = nothing","category":"page"},{"location":"sketches/stochastic_simulation/anderson.html#Clock-Process","page":"Simulating Stochastic Reaction Systems","title":"Clock Process","text":"","category":"section"},{"location":"sketches/stochastic_simulation/anderson.html","page":"Simulating Stochastic Reaction Systems","title":"Simulating Stochastic Reaction Systems","text":"The key concept in Anderson (2007) is that the stochastic system is defined by a set of clocks, each of which fires at the points of an inhomogeneous Poisson process. Strictly speaking, each clock process k also has an associated marking nu_k, which updates the state of the system. Let M be the total number of clock processes.","category":"page"},{"location":"sketches/stochastic_simulation/anderson.html","page":"Simulating Stochastic Reaction Systems","title":"Simulating Stochastic Reaction Systems","text":"Consider the state X(t) at a time t to be a vector of integers. Let each clock process have an associated counting process R_k(t) which tells us the number of times it has fired up to time t. Then we can write the current model state as a function of the set of all counting processes, their markings, and the initial condition as:","category":"page"},{"location":"sketches/stochastic_simulation/anderson.html","page":"Simulating Stochastic Reaction Systems","title":"Simulating Stochastic Reaction Systems","text":"X(t) = X(0) + sum_k=1^M R_k(t) nu_k","category":"page"},{"location":"sketches/stochastic_simulation/anderson.html","page":"Simulating Stochastic Reaction Systems","title":"Simulating Stochastic Reaction Systems","text":"We can write each counting process as arising from an inhomogenous Poisson process with intensity function a_k(X). Specific forms of a_k and nu_k will make meaningful models for chemical reactions, ecological systems, epidemiological processes, sociology, or other domains.","category":"page"},{"location":"sketches/stochastic_simulation/anderson.html","page":"Simulating Stochastic Reaction Systems","title":"Simulating Stochastic Reaction Systems","text":"R_k(t) = Y_kleft(int_0^ta_k(X(s))dsright)","category":"page"},{"location":"sketches/stochastic_simulation/anderson.html","page":"Simulating Stochastic Reaction Systems","title":"Simulating Stochastic Reaction Systems","text":"The above is therefore an expression of the counting process in terms of a unit rate Poisson process Y_k. Via the random time change theorem by transforming time according to the integrated intensity T_k(t) = int_0^ta_k(X(s))ds we get the proper inhomogeneous Poisson process, such that when the intensity is high, more events occur (i.e. the inter-arrival time is smaller), and vice-versa for low intensity.","category":"page"},{"location":"sketches/stochastic_simulation/anderson.html","page":"Simulating Stochastic Reaction Systems","title":"Simulating Stochastic Reaction Systems","text":"To apply the method of Anderson (2007) we need one more definition, P_k, which is the next firing time of T_k, applying the random time change such that it advances at unit exponentially-distributed increments.","category":"page"},{"location":"sketches/stochastic_simulation/anderson.html","page":"Simulating Stochastic Reaction Systems","title":"Simulating Stochastic Reaction Systems","text":"  P_k = s  T_k  Y_k(s)  Y_k(T_k) ","category":"page"},{"location":"sketches/stochastic_simulation/anderson.html","page":"Simulating Stochastic Reaction Systems","title":"Simulating Stochastic Reaction Systems","text":"Now let us define R_k using the @aagent macro from AlgebraicAgents. It contains data members:","category":"page"},{"location":"sketches/stochastic_simulation/anderson.html","page":"Simulating Stochastic Reaction Systems","title":"Simulating Stochastic Reaction Systems","text":"P: the next internal firing time of the homogeneous Poisson process\nT: the internal time of the homogeneous Poisson process\nΔt: absolute (wall-clock) time time before next putative firing\nτ: next asbolute putative time to fire\na: current value of a_k\nintensity: the intensity function a_k, which accepts as input X and returns floating point value\nν: the marking which updates state (a vector)","category":"page"},{"location":"sketches/stochastic_simulation/anderson.html","page":"Simulating Stochastic Reaction Systems","title":"Simulating Stochastic Reaction Systems","text":"@aagent struct Clock{N<:Real,Fn<:Function,S<:Number}\n    P::N\n    T::N\n    Δt::N\n    τ::N\n    a::N\n    intensity::Fn\n    ν::Vector{S}\nend","category":"page"},{"location":"sketches/stochastic_simulation/anderson.html","page":"Simulating Stochastic Reaction Systems","title":"Simulating Stochastic Reaction Systems","text":"We must now define a method which adds a clock process to an object of type ReactionSystem. This \"initialization\" method implements steps 1-5 of Algorithm 3 in Anderson's paper. Readers should note that we include step 5 as initialization and then compute it again at the end of the loop via using a control interaction because of how AlgebraicAgents structures updates.","category":"page"},{"location":"sketches/stochastic_simulation/anderson.html","page":"Simulating Stochastic Reaction Systems","title":"Simulating Stochastic Reaction Systems","text":"function add_clock!(rs::ReactionSystem, name::T, intensity::U, ν::Vector{S}) where {T,U,S}\n    c = Clock{Float64,U,S}(name, 0.0, 0.0, 0.0, 0.0, 0.0, intensity, ν)\n\n    c.a = c.intensity(rs.X)\n    c.P = rand(Exponential())\n    c.Δt = (c.P - c.T) / c.a\n    c.τ += c.Δt\n\n    entangle!(inners(rs)[\"clocks\"], c)\n\n    add_control!(rs, () -> control_clock(c), \"control \" * name)\nend","category":"page"},{"location":"sketches/stochastic_simulation/anderson.html","page":"Simulating Stochastic Reaction Systems","title":"Simulating Stochastic Reaction Systems","text":"We must implement AlgebraicAgents._projected_to for the type Clock. Here it will return the putative times to fire. This is because the simulation method (and many other continuous time discrete event simulation algorithms) updates via a race condition, where the next event to cause a state change is the one that \"actually happens\". AlgebraicAgents selects the agent(s) to _step! as the ones whose projected time is the minimum of all projected times, so that the clock that fires first will be the one whose dynamics occur for this next iteration of the simulation loop. Because the next times are sampled from the points of Poisson processes they almost surely occur at unique times, and therefore conflicts cannot occur.","category":"page"},{"location":"sketches/stochastic_simulation/anderson.html","page":"Simulating Stochastic Reaction Systems","title":"Simulating Stochastic Reaction Systems","text":"It is interesting to note here that AlgebraicAgents can implement any algorithm that depends on such a race condition.","category":"page"},{"location":"sketches/stochastic_simulation/anderson.html","page":"Simulating Stochastic Reaction Systems","title":"Simulating Stochastic Reaction Systems","text":"function AlgebraicAgents._projected_to(c::Clock)\n    c.τ\nend","category":"page"},{"location":"sketches/stochastic_simulation/anderson.html","page":"Simulating Stochastic Reaction Systems","title":"Simulating Stochastic Reaction Systems","text":"Now we implement AlgebraicAgents._step! for type Clock. In this method, steps 6,7, and 9 of Algorithm 3 from the paper are implemented (specific order of 8 and 9 is not important). Basically, we update the global time to the time this clock fired, update the state X, and draw the new next firing time P_k. We also push output to the top level agent, which is of type ReactionSystem. Each update log will have the time of the event, the name of the clock that caused it, and the new system state.","category":"page"},{"location":"sketches/stochastic_simulation/anderson.html","page":"Simulating Stochastic Reaction Systems","title":"Simulating Stochastic Reaction Systems","text":"function AlgebraicAgents._step!(c::Clock)\n\n    if isinf(c.τ)\n        return nothing\n    end\n\n    topmost(c).Δ = c.τ - topmost(c).t\n    topmost(c).t = c.τ\n    topmost(c).X += c.ν\n    c.P += rand(Exponential())\n\n    push!(topmost(c).df_output, [topmost(c).t, getname(c), topmost(c).X...])\nend","category":"page"},{"location":"sketches/stochastic_simulation/anderson.html","page":"Simulating Stochastic Reaction Systems","title":"Simulating Stochastic Reaction Systems","text":"Finally we must implement the control interaction which is applied to each clock at the end of an iteration in the loop. This implements steps 8,9, and 5 of Algorithm 3 (note that we are allowed to move step 5 to the end because we also included it in the \"initialization\" phase earlier). It also updates the putative next firing time.","category":"page"},{"location":"sketches/stochastic_simulation/anderson.html","page":"Simulating Stochastic Reaction Systems","title":"Simulating Stochastic Reaction Systems","text":"function control_clock(c::Clock)\n    c.T += c.a * topmost(c).Δ\n    c.a = c.intensity(topmost(c).X)\n    c.Δt = (c.P - c.T) / c.a\n    c.τ = topmost(c).t + c.Δt\nend","category":"page"},{"location":"sketches/stochastic_simulation/anderson.html#Simulation","page":"Simulating Stochastic Reaction Systems","title":"Simulation","text":"","category":"section"},{"location":"sketches/stochastic_simulation/anderson.html","page":"Simulating Stochastic Reaction Systems","title":"Simulating Stochastic Reaction Systems","text":"We will simulate a continuous time stochastic SIR (Susceptible-Infectious-Recovered) model. For mathematical details on this model, please consult Allen (2017). Let us use parameters beta to represent the effective contact rate, and gamma to represent the recovery rate.","category":"page"},{"location":"sketches/stochastic_simulation/anderson.html","page":"Simulating Stochastic Reaction Systems","title":"Simulating Stochastic Reaction Systems","text":"β = 0.05*10.0\nγ = 0.25","category":"page"},{"location":"sketches/stochastic_simulation/anderson.html","page":"Simulating Stochastic Reaction Systems","title":"Simulating Stochastic Reaction Systems","text":"Now we make a ReactionSystem object, and initialize it to a population with 990 susceptible persons, 10 infectious persons, and 0 recovered persons. The two events in the system are infection and recovery, which fire according to the rates given by the anonymous functions passed to add_clock!.","category":"page"},{"location":"sketches/stochastic_simulation/anderson.html","page":"Simulating Stochastic Reaction Systems","title":"Simulating Stochastic Reaction Systems","text":"rs = make_reactionsystem(\"SIR\", [990, 10, 0])\nadd_clock!(rs, \"infection\", (x) -> β*x[2]/sum(x)*x[1], [-1,1,0])\nadd_clock!(rs, \"recovery\", (x) -> γ*x[2], [0,-1,1])","category":"page"},{"location":"sketches/stochastic_simulation/anderson.html","page":"Simulating Stochastic Reaction Systems","title":"Simulating Stochastic Reaction Systems","text":"Now we call simulate on the constructed system. Because a clock will return a next event time of Inf when its rate is 0 (meaning it will never fire again), when all clocks return Inf it means the simulation is over, because nothing else can happen. Therefore we pass as the second argument to simulate the largest representable floating point value. When all clocks return Inf, the minimum will be larger than this value and the simulation loop will end.","category":"page"},{"location":"sketches/stochastic_simulation/anderson.html","page":"Simulating Stochastic Reaction Systems","title":"Simulating Stochastic Reaction Systems","text":"simulate(rs, floatmax(Float64))","category":"page"},{"location":"sketches/stochastic_simulation/anderson.html","page":"Simulating Stochastic Reaction Systems","title":"Simulating Stochastic Reaction Systems","text":"After simulation is complete, we can extract the simulated trajectory.","category":"page"},{"location":"sketches/stochastic_simulation/anderson.html","page":"Simulating Stochastic Reaction Systems","title":"Simulating Stochastic Reaction Systems","text":"df_out = select(rs.df_output, Not(:clock));\nplot(df_out[!,:time], Matrix(df_out[:,[:X1,:X2,:X3]]), label = [\"S\" \"I\" \"R\"])","category":"page"},{"location":"index.html#API-Documentation","page":"API Documentation","title":"API Documentation","text":"","category":"section"},{"location":"index.html","page":"API Documentation","title":"API Documentation","text":"CurrentModule = AlgebraicAgents","category":"page"},{"location":"index.html#Agent-types","page":"API Documentation","title":"Agent types","text":"","category":"section"},{"location":"index.html","page":"API Documentation","title":"API Documentation","text":"AbstractAlgebraicAgent\nFreeAgent\nFreeAgent(::AbstractString, ::Vector{<:AbstractAlgebraicAgent})","category":"page"},{"location":"index.html#AlgebraicAgents.AbstractAlgebraicAgent","page":"API Documentation","title":"AlgebraicAgents.AbstractAlgebraicAgent","text":"AbstractAlgebraicAgent\n\nAbstract supertype of all algebraic agents. This is a dynamic structure which parametrizes dynamics of the agent, stores additional data required for the numerical simulation,  and optionally logs its state at selected timesteps.\n\n\n\n\n\n","category":"type"},{"location":"index.html#AlgebraicAgents.FreeAgent","page":"API Documentation","title":"AlgebraicAgents.FreeAgent","text":"A container of agents. Doesn't implement a standalone evolutionary rule; delegates evolution to internal agents.\n\n\n\n\n\n","category":"type"},{"location":"index.html#AlgebraicAgents.FreeAgent-Tuple{AbstractString, Vector{<:AbstractAlgebraicAgent}}","page":"API Documentation","title":"AlgebraicAgents.FreeAgent","text":"FreeAgent(name, agents=[])\n\nInitialize an agent. Optionally provide contained agents at the time of instantiation. See also entangle! and disentangle!.\n\nExamples\n\nFreeAgent(\"agent\", [agent1, agent2])\n\n\n\n\n\n","category":"method"},{"location":"index.html#Implementing-custom-types","page":"API Documentation","title":"Implementing custom types","text":"","category":"section"},{"location":"index.html","page":"API Documentation","title":"API Documentation","text":"To implement a custom agent type, you may want to use the convenience macro @aagent which supplies type fields expected (not required, though) by the interface.","category":"page"},{"location":"index.html#Required-methods","page":"API Documentation","title":"Required methods","text":"","category":"section"},{"location":"index.html","page":"API Documentation","title":"API Documentation","text":"AlgebraicAgents._step!(::AbstractAlgebraicAgent)\nAlgebraicAgents._projected_to(::AbstractAlgebraicAgent)","category":"page"},{"location":"index.html#AlgebraicAgents._step!-Tuple{AbstractAlgebraicAgent}","page":"API Documentation","title":"AlgebraicAgents._step!","text":"Step an agent forward (call only if its projected time is equal to the least projected time, among all agents in the hierarchy).\n\n\n\n\n\n","category":"method"},{"location":"index.html#AlgebraicAgents._projected_to-Tuple{AbstractAlgebraicAgent}","page":"API Documentation","title":"AlgebraicAgents._projected_to","text":"Return time to which agent's evolution was projected.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Optional-methods","page":"API Documentation","title":"Optional methods","text":"","category":"section"},{"location":"index.html","page":"API Documentation","title":"API Documentation","text":"AlgebraicAgents._getparameters(::AbstractAlgebraicAgent)\nAlgebraicAgents._setparameters!(::AbstractAlgebraicAgent, ::Any)\nAlgebraicAgents._draw(::AbstractAlgebraicAgent)\nAlgebraicAgents._reinit!(::AbstractAlgebraicAgent)\nAlgebraicAgents._interact!(::AbstractAlgebraicAgent)\nAlgebraicAgents._prestep!(::AbstractAlgebraicAgent, ::Float64)","category":"page"},{"location":"index.html#AlgebraicAgents._getparameters-Tuple{AbstractAlgebraicAgent}","page":"API Documentation","title":"AlgebraicAgents._getparameters","text":"_getparameters(agent)\n\nRetrieve parameter space of an agent.\n\n\n\n\n\n","category":"method"},{"location":"index.html#AlgebraicAgents._setparameters!-Tuple{AbstractAlgebraicAgent, Any}","page":"API Documentation","title":"AlgebraicAgents._setparameters!","text":"_setparameters!\n\nMutate agent's parameter space.\n\nExamples\n\n_setparameters!(agent, Dict(:α=>1))\n_setparameters!(agent, [1., 2.])\n\n\n\n\n\n","category":"method"},{"location":"index.html#AlgebraicAgents._draw-Tuple{AbstractAlgebraicAgent}","page":"API Documentation","title":"AlgebraicAgents._draw","text":"Return plot of an agent's state. Defaults to nothing.\n\n\n\n\n\n","category":"method"},{"location":"index.html#AlgebraicAgents._reinit!-Tuple{AbstractAlgebraicAgent}","page":"API Documentation","title":"AlgebraicAgents._reinit!","text":"Reinitialize the state of an agent.\n\n\n\n\n\n","category":"method"},{"location":"index.html#AlgebraicAgents._interact!-Tuple{AbstractAlgebraicAgent}","page":"API Documentation","title":"AlgebraicAgents._interact!","text":"Wake up an agent. See Opera.\n\n\n\n\n\n","category":"method"},{"location":"index.html#AlgebraicAgents._prestep!-Tuple{AbstractAlgebraicAgent, Float64}","page":"API Documentation","title":"AlgebraicAgents._prestep!","text":"Pre-step to a step call (e.g., projecting agent's solution up to time t).\n\n\n\n\n\n","category":"method"},{"location":"index.html","page":"API Documentation","title":"API Documentation","text":"Other optional methods include","category":"page"},{"location":"index.html","page":"API Documentation","title":"API Documentation","text":"getobservable(::AbstractAlgebraicAgent, ::Any)\nobservables(::AbstractAlgebraicAgent)\nwrap_system\nextract_agent","category":"page"},{"location":"index.html#Loading-third-party-package-integrations","page":"API Documentation","title":"Loading third-party package integrations","text":"","category":"section"},{"location":"index.html","page":"API Documentation","title":"API Documentation","text":"So far, integrations of DifferentialEquations.jl, Agents.jl, and AlgebraicDynamics.jl are provided.","category":"page"},{"location":"index.html","page":"API Documentation","title":"API Documentation","text":"Loading of the integrations is facilitated by Requires.jl; the integration will automatically be included once the respective third-party package is loaded.","category":"page"},{"location":"index.html","page":"API Documentation","title":"API Documentation","text":"For example,","category":"page"},{"location":"index.html","page":"API Documentation","title":"API Documentation","text":"using AlgebraicAgents\n@isdefined DiffEqAgent","category":"page"},{"location":"index.html","page":"API Documentation","title":"API Documentation","text":"using AlgebraicAgents, DifferentialEquations\n@isdefined DiffEqAgent\nwrap_system(\"my_model\", ODEProblem((u, p, t) -> 1.01*u, [1/2], (0., 10.)))","category":"page"},{"location":"index.html","page":"API Documentation","title":"API Documentation","text":"For plotting, you will want to load Plots as well. Nevertheless, function draw will inform you when necessary.","category":"page"},{"location":"index.html#Common-interface","page":"API Documentation","title":"Common interface","text":"","category":"section"},{"location":"index.html#Agent-properties-accessors","page":"API Documentation","title":"Agent properties accessors","text":"","category":"section"},{"location":"index.html","page":"API Documentation","title":"API Documentation","text":"getname\ngetuuid\ngetparent\ninners\ngetopera\ngetdirectory\ngetparameters\nsetparameters!","category":"page"},{"location":"index.html#AlgebraicAgents.getname","page":"API Documentation","title":"AlgebraicAgents.getname","text":"getname(agent)\n\nGet agent's name.\n\n\n\n\n\n","category":"function"},{"location":"index.html#AlgebraicAgents.getuuid","page":"API Documentation","title":"AlgebraicAgents.getuuid","text":"getuuid(agent)\n\nGet agent's uuid.\n\n\n\n\n\n","category":"function"},{"location":"index.html#AlgebraicAgents.getparent","page":"API Documentation","title":"AlgebraicAgents.getparent","text":"getparent(agent)\n\nGet agent's parent.\n\n\n\n\n\n","category":"function"},{"location":"index.html#AlgebraicAgents.inners","page":"API Documentation","title":"AlgebraicAgents.inners","text":"inners(agent)\n\nGet dictionary of agent's inner agents. Follows name => agent format.\n\n\n\n\n\n","category":"function"},{"location":"index.html#AlgebraicAgents.getopera","page":"API Documentation","title":"AlgebraicAgents.getopera","text":"Get agent's Opera.\n\n\n\n\n\n","category":"function"},{"location":"index.html#AlgebraicAgents.getdirectory","page":"API Documentation","title":"AlgebraicAgents.getdirectory","text":"Get agent's directory. See also Opera.\n\n\n\n\n\n","category":"function"},{"location":"index.html#AlgebraicAgents.getparameters","page":"API Documentation","title":"AlgebraicAgents.getparameters","text":"getparameters(agent)\n\nRetrieve agents' (incl. inner agents, if applicable) parameter space.\n\n\n\n\n\n","category":"function"},{"location":"index.html#AlgebraicAgents.setparameters!","page":"API Documentation","title":"AlgebraicAgents.setparameters!","text":"setparameters!(agent, parameters)\n\nAssign agent's parameters. Parameters are accepted in the form of a dictionary containing path => params pairs.\n\nExamples\n\nsetparameters!(agent, Dict(\"agent1/agent2\" => Dict(:α=>1)))\n\n\n\n\n\n","category":"function"},{"location":"index.html#Observables","page":"API Documentation","title":"Observables","text":"","category":"section"},{"location":"index.html","page":"API Documentation","title":"API Documentation","text":"observables\ngetobservable\ngettimeobservable","category":"page"},{"location":"index.html#AlgebraicAgents.observables","page":"API Documentation","title":"AlgebraicAgents.observables","text":"observables(agent)\n\nReturn a list of observables (explicitly) exported by an agent. Use getobservable to retrieve the observable's value.\n\n\n\n\n\n","category":"function"},{"location":"index.html#AlgebraicAgents.getobservable","page":"API Documentation","title":"AlgebraicAgents.getobservable","text":"getobservable(agent, args...)\n\nGet agent's observable.\n\nExamples\n\ngetobservable(getagent(agent, \"../model\"), \"observable_name\")\ngetobservable(getagent(agent, \"../model\"), 1)\n\n\n\n\n\n","category":"function"},{"location":"index.html#AlgebraicAgents.gettimeobservable","page":"API Documentation","title":"AlgebraicAgents.gettimeobservable","text":"Get agent's observable at a given time.\n\n\n\n\n\n","category":"function"},{"location":"index.html#Solving-and-plotting","page":"API Documentation","title":"Solving & plotting","text":"","category":"section"},{"location":"index.html","page":"API Documentation","title":"API Documentation","text":"step!\nsimulate\ndraw","category":"page"},{"location":"index.html#AlgebraicAgents.step!","page":"API Documentation","title":"AlgebraicAgents.step!","text":"step!(agent, t=projected_to(agent))\n\nPerforms a single evolutionary step of the hierarchy. To avoid frontrunning, solutions will be projected only up to time t. This is a two-phase step; the corresponding stepping functions are _prestep! and step!.\n\nMore particular behavior can be implemented using Opera protocol.\n\nFor custom agents' types, it suffices to implement _step!.\n\nReturn values\n\nReturn true if all internal agent's time horizon was reached. Else return the minimum time up to which the agent's solution was projected.\n\n\n\n\n\n","category":"function"},{"location":"index.html#AlgebraicAgents.simulate","page":"API Documentation","title":"AlgebraicAgents.simulate","text":"simulate(agent::AbstractAlgebraicAgent, max_t=Inf)::AbstractAlgebraicAgent\n\nSolves an (initialized) problem.  Runs a loop until all the agents return true (reached simulation horizon) or nothing (delegated evolution), or until the simulation horizon reaches max_t. Avoids front-running.\n\nExamples\n\nsol = simulate(model)\n\n\n\n\n\n","category":"function"},{"location":"index.html#AlgebraicAgents.draw","page":"API Documentation","title":"AlgebraicAgents.draw","text":"Plot an agent's state. For internal implementation, see _draw.\n\n\n\n\n\n","category":"function"},{"location":"index.html#Paths","page":"API Documentation","title":"Paths","text":"","category":"section"},{"location":"index.html","page":"API Documentation","title":"API Documentation","text":"Implements path-like structure of agents.","category":"page"},{"location":"index.html","page":"API Documentation","title":"API Documentation","text":"@glob_str\n@uuid_str\ngetagent\nby_name","category":"page"},{"location":"index.html#AlgebraicAgents.@glob_str","page":"API Documentation","title":"AlgebraicAgents.@glob_str","text":"Returns a glob string to enable wildcard matching of agents paths.\n\n\n\n\n\n","category":"macro"},{"location":"index.html#AlgebraicAgents.@uuid_str","page":"API Documentation","title":"AlgebraicAgents.@uuid_str","text":"Returns UUID object given a uuid string.\n\n\n\n\n\n","category":"macro"},{"location":"index.html#AlgebraicAgents.getagent","page":"API Documentation","title":"AlgebraicAgents.getagent","text":"Retrieve an agent at path, relatively to agent.\n\n\n\n\n\ngetagent(a::AbstractAlgebraicAgent, uuid::UUID)\n\nGet an agent given its uuid.\n\nExamples\n\ngetagent(a, UUID(\"2a634aad-0fbe-4a91-a605-bfbef4d57f95\"))\ngetagent(a, uuid\"2a634aad-0fbe-4a91-a605-bfbef4d57f95\")\n\n\n\n\n\ngetagent(agent::AbstractAlgebraicAgent, path::AbstractString)\n\nGet an agent given its relative path.\n\nExamples\n\ngetagent(a, \"../agent\")\n\n\n\n\n\ngetagent(agent::AbstractAlgebraicAgent, path::Union{Glob.FilenameMatch, Regex})\n\nGet an agent given a regex or glob string.\n\nExamples\n\ngetagent(a, r\"agent.*\")\ngetagent(a, glob\"**/agent/\")\n\n\n\n\n\n","category":"function"},{"location":"index.html#AlgebraicAgents.by_name","page":"API Documentation","title":"AlgebraicAgents.by_name","text":"by_name(agent, name::AbstractString; inners_only=false)\n\nReturn agents in the hierachy with the given name. If inners_only==true, consider descendants of agent only.\n\n\n\n\n\nby_name(agent, name::Union{Glob.FilenameMatch, Regex})\n\nReturn agents in the hierarchy whose names match the given wildcard. If inners_only==true, consider descendants of agent only.\n\n\n\n\n\n","category":"function"},{"location":"index.html#Opera,-a-dynamic-structure-to-facilitate-complex-interactions","page":"API Documentation","title":"Opera, a dynamic structure to facilitate complex interactions","text":"","category":"section"},{"location":"index.html","page":"API Documentation","title":"API Documentation","text":"Opera\npoke\n@call\nadd_instantious!\n@future\nadd_future!\n@control\nadd_control!","category":"page"},{"location":"index.html#AlgebraicAgents.Opera","page":"API Documentation","title":"AlgebraicAgents.Opera","text":"Opera(uuid2agent_pairs...)\n\nA dynamic structure that \n\ncontains a directory of agents (dictionary of uuid => agent pairs);\nkeeps track of, and executes, futures (delayed interactions);\nkeeps track of, and executes, system controls;\nkeeps track of, and executes, instantious interactions;\n\nFutures\n\nYou may schedule function calls, to be executed at predetermined points of time. An action is modeled as a tuple (id, call, time), where id is an optional textual identifier of the action and call is a (parameterless) anonymous function, which will be called at the given time. Once the action is executed, the return value with corresponding action id and execution time is added to futures_log field of Opera instance.\n\nSee add_future! and @future.\n\nExample\n\nalice = MyAgentType(\"alice\")\ninteract = agent -> wake_up!(agent)\n@future alice 5.0 interact(alice) \"alice_schedule\"\n\nThe solver will stop at t=5 and call the function () -> interact(alice) (a closure is taken at the time when @future is invoked). This interaction is identified as \"alice_schedule\".\n\nControl Interactions\n\nYou may schedule control function calls, to be executed at every step of the model. An action is modeled as a tuple (id, call), where id is an optional textual identifier of the action, and call is a (parameterless) anonymous function. Once the action is executed, the return value with corresponding action id and execution time is added to controls_log field of Opera instance.\n\nSee add_control! and @control.\n\nExample\n\nsystem = MyAgentType(\"system\")\ncontrol = agent -> agent.temp > 100 && cool!(agent)\n@control system control(system) \"temperature control\"\n\nAt each step, the solver will call the function () -> control(system) (a closure is taken at the time when @future is invoked).\n\nInstantious Interactions\n\nYou may schedule additional interactions which exist within a single step of the model; such actions are modeled as named tuples (id, priority=0., call). Here, call is a (parameterless) anonymous function.\n\nThey exist within a single step of the model and are executed after the calls to _prestep! and _step! finish, in the order of the assigned priorities.\n\nIn particular, you may schedule interactions of two kinds:\n\npoke(agent, priority), which will translate into a call () -> _interact!(agent), with the specified priority,\n@call opera expresion priority, which will translate into a call () -> expression, with the specified priority.\n\nSee poke and @call.\n\nExamples\n\n# `poke`\npoke(agent, 1.) # call `_interact!(agent)`; this call is added to the instantious priority queue with priority 1\n\n# `@call`\nbob_agent = only(getagent(agent, r\"bob\"))\n@call agent wake_up(bob_agent) # translates into `() -> wake_up(bob_agent)` with priority 0\n\n\n\n\n\n","category":"type"},{"location":"index.html#AlgebraicAgents.poke","page":"API Documentation","title":"AlgebraicAgents.poke","text":"poke(agent, priority=0[, id])\n\nPoke an agent in the current time step. Translates to a call () -> _interact(agent), see @call.\n\nInteractions are implemented within an instance Opera, sorted by their priorities.\n\nSee also Opera.\n\nExamples\n\npoke(agent)\npoke(agent, 1.) # with priority equal to 1\n\n\n\n\n\n","category":"function"},{"location":"index.html#AlgebraicAgents.@call","page":"API Documentation","title":"AlgebraicAgents.@call","text":"@call agent call [priority[, id]]\n@call opera call [priority[, id]]\n\nSchedule an interaction (call), which will be executed in the current time step. Here, call will translate into a function () -> call.\n\nInteractions are implemented within an instance Opera, sorted by their priorities.\n\nSee also Opera.\n\nExamples\n\nbob_agent = only(getagent(agent, r\"bob\"))\n@call agent wake_up(bob_agent) # translates into `() -> wake_up(bob_agent)`\n\n\n\n\n\n","category":"macro"},{"location":"index.html#AlgebraicAgents.add_instantious!","page":"API Documentation","title":"AlgebraicAgents.add_instantious!","text":"add_instantious!(opera, call, priority=0[, id])\nadd_instantious!(agent, call, priority=0[, id])\n\nSchedule a call to be executed in the current time step.\n\nInteractions are implemented within an instance Opera, sorted by their priorities.\n\nSee also Opera.\n\nExamples\n\nadd_instantious!(agent, () -> wake_up(agent))\n\n\n\n\n\n","category":"function"},{"location":"index.html#AlgebraicAgents.@future","page":"API Documentation","title":"AlgebraicAgents.@future","text":"@future opera time call [id]\n@future agent time call [id]\n\nSchedule a (delayed) execution of call at time. Optionally, provide a textual identifier id of the action.\n\ncall is an expression, which will be wrapped into a function () -> call (taking closure at the time when @future is invoked).\n\nSee also @future and Opera.\n\nExamples\n\nalice = MyAgentType(\"alice\")\ninteract = agent -> wake_up!(agent)\n@future alice 5.0 interact(alice) \"alice_schedule\" # stop at `t=5`\n\n\n\n\n\n","category":"macro"},{"location":"index.html#AlgebraicAgents.add_future!","page":"API Documentation","title":"AlgebraicAgents.add_future!","text":"add_future!(opera, time, call[, id])\nadd_future!(agent, time, call[, id])\n\nSchedule a (delayed) execution of call at time. Optionally, provide a textual identifier id of the action.\n\nHere, call has to follow either of the following forms:     - be parameterless,     - be a function of Opera instance,     - be a function of the topmost agent in the hierarchy. This follows the dynamic dispatch.\n\nSee also Opera.\n\nExamples\n\nalice = MyAgentType(\"alice\")\ninteract = agent -> wake_up!(agent)\nadd_future!(alice, 5.0, () -> interact(alice), \"alice_schedule\")\n\n\n\n\n\n","category":"function"},{"location":"index.html#AlgebraicAgents.@control","page":"API Documentation","title":"AlgebraicAgents.@control","text":"@control opera call [id]\n@control agent call [id]\n\nAdd a control to the system. Optionally, provide a textual identifier id of the action.\n\ncall is an expression, which will be wrapped into an anonymous, parameterless function () -> call.\n\nSee also Opera.\n\nExamples\n\nsystem = MyAgentType(\"system\")\ncontrol = agent -> agent.temp > 100 && cool!(agent)\n@control system control(system) \"temperature control\"\n\n\n\n\n\n","category":"macro"},{"location":"index.html#AlgebraicAgents.add_control!","page":"API Documentation","title":"AlgebraicAgents.add_control!","text":"add_control!(opera, call[, id])\nadd_control!(agent, call[, id])\n\nAdd a control to the system. Optionally, provide a textual identifier id of the action.\n\nHere, call has to follow either of the following forms:     - be parameterless,     - be a function of Opera instance,     - be a function of the topmost agent in the hierarchy. This follows the dynamic dispatch.\n\nSee also @control and Opera.\n\nExamples\n\nsystem = MyAgentType(\"system\")\ncontrol = agent -> agent.temp > 100 && cool!(agent)\nadd_control!(system, () -> control(system), \"temperature control\")\n\n\n\n\n\n","category":"function"},{"location":"index.html#Operations","page":"API Documentation","title":"Operations","text":"","category":"section"},{"location":"index.html","page":"API Documentation","title":"API Documentation","text":"Defines sums of agents.","category":"page"},{"location":"index.html","page":"API Documentation","title":"API Documentation","text":"⊕\n@sum","category":"page"},{"location":"index.html#AlgebraicAgents.:⊕","page":"API Documentation","title":"AlgebraicAgents.:⊕","text":"⊕(models::Vararg{AbstractAlgebraicAgent, N}; name)\n\nAlgebraic sum of algebraic models. Optionally specify resulting model's name.\n\nBy default, outputs an instance of FreeAgent.\n\nExamples\n\n⊕(m1, m2; name=\"diagram1\") ⊕ ⊕(m3, m4; name=\"diagram2\");\n\n\n\n\n\n⊕(system1, system2; diagram=pattern, name)\n⊕([system1, system2]; diagram=pattern, name)\n⊕(Dict(:system1 => system1, :system2 => system2); diagram=pattern, name)\n\nApply oapply(diagram, systems...) and wrap the result as a GraphicalAgent.\n\n\n\n\n\n⊕(system1, system2; diagram=pattern, name)\n⊕([system1, system2]; diagram=pattern, name)\n⊕(Dict(:system1 => system1, :system2 => system2); diagram=pattern, name)\n\nApply oapply(diagram, systems...) and wrap the result as a GraphicalAgent.\n\n\n\n\n\n⊕(system1, system2; diagram=pattern, name)\n⊕([system1, system2]; diagram=pattern, name)\n⊕(Dict(:system1 => system1, :system2 => system2); diagram=pattern, name)\n\nApply oapply(diagram, systems...) and wrap the result as a GraphicalAgent.\n\n\n\n\n\n⊕(system1, system2; diagram=pattern, name)\n⊕([system1, system2]; diagram=pattern, name)\n⊕(Dict(:system1 => system1, :system2 => system2); diagram=pattern, name)\n\nApply oapply(diagram, systems...) and wrap the result as a GraphicalAgent.\n\n\n\n\n\n","category":"function"},{"location":"index.html#AlgebraicAgents.@sum","page":"API Documentation","title":"AlgebraicAgents.@sum","text":"@sum models...\n\nPerform an algebraic sum of algebraic models (flatten arguments to ⊕).\n\nExamples\n\n@sum m1 m2 m3 m4 # == ⊕(m1, m2, m3, m4)\n\n\n\n\n\n","category":"macro"},{"location":"index.html","page":"API Documentation","title":"API Documentation","text":"Entangle and disentangle agents hierarchies.","category":"page"},{"location":"index.html","page":"API Documentation","title":"API Documentation","text":"entangle!\ndisentangle!","category":"page"},{"location":"index.html#AlgebraicAgents.entangle!","page":"API Documentation","title":"AlgebraicAgents.entangle!","text":"entangle!(parent, agent)\n\nPush an agent to the hierachy.\n\nExamples\n\nentagle!(parent, ancestor)\n\n\n\n\n\n","category":"function"},{"location":"index.html#AlgebraicAgents.disentangle!","page":"API Documentation","title":"AlgebraicAgents.disentangle!","text":"disentangle!(agent)\n\nDetach an agent from its parent. Optionally set remove_relpathrefs=false keyword to skip removing the relative pathrefs.\n\nExamples\n\ndisentangle!(agent)\n\n\n\n\n\n","category":"function"},{"location":"index.html#Agent-type-constructors","page":"API Documentation","title":"Agent type constructors","text":"","category":"section"},{"location":"index.html","page":"API Documentation","title":"API Documentation","text":"Supports convenient agent subtyping.","category":"page"},{"location":"index.html","page":"API Documentation","title":"API Documentation","text":"@aagent","category":"page"},{"location":"index.html#AlgebraicAgents.@aagent","page":"API Documentation","title":"AlgebraicAgents.@aagent","text":"@aagent [OptionalBasetype=FreeAgent] [OptionalSupertype=AbstractAlgebraicAgent] struct my_agent\n    extra_fields...\nend\n\nDefine a custom agent type, and include fields expected by default interface methods (see FreeAgent).\n\nFields are mutable by default, but can be declared immutable using const keyword.\n\nProvides a constructor which takes agent's name at the input, and populates the common fields.\n\nExample\n\n@aagent struct Molecule\n    age::Float64\n    birth_time::Float64\n    sales::Float64\nend\n\nOptional base type:\n\n@aagent FreeAgent struct Molecule\n    age::Float64\n    birth_time::Float64\n    sales::Float64\nend\n\nOptional base type and a super type:\n\n@aagent FreeAgent AbstractMolecule struct Molecule\n    age::Float64\n    birth_time::Float64\n    sales::Float64\nend\n\nParametric types:\n\n@aagent struct MyAgent{T <: Real, P <: Real}\n    field1::T\n    field2::P\nend\n\nMyAgent{Float64, Int}(\"myagent\", 1, 2)\n\n\n\n\n\n","category":"macro"},{"location":"index.html","page":"API Documentation","title":"API Documentation","text":"To provide custom specialization of @aagent convenience macros, see AlgebraicAgents.define_agent.","category":"page"},{"location":"index.html","page":"API Documentation","title":"API Documentation","text":"AlgebraicAgents.define_agent","category":"page"},{"location":"index.html#AlgebraicAgents.define_agent","page":"API Documentation","title":"AlgebraicAgents.define_agent","text":"define_agent(base_type, super_type, type, __module, constructor)\n\nA function to define an agent type. See the definition of @aagent.\n\n\n\n\n\n","category":"function"},{"location":"index.html#Walks","page":"API Documentation","title":"Walks","text":"","category":"section"},{"location":"index.html","page":"API Documentation","title":"API Documentation","text":"Walk agents' hierarchy.","category":"page"},{"location":"index.html","page":"API Documentation","title":"API Documentation","text":"prewalk\npostwalk\nprewalk_ret\npostwalk_ret","category":"page"},{"location":"index.html#AlgebraicAgents.prewalk","page":"API Documentation","title":"AlgebraicAgents.prewalk","text":"Applies f to each agent. Applies f to an agent before visiting its inners.\n\n\n\n\n\n","category":"function"},{"location":"index.html#AlgebraicAgents.postwalk","page":"API Documentation","title":"AlgebraicAgents.postwalk","text":"Applies f to each agent. Applies f to an agent after visiting its inners.\n\n\n\n\n\n","category":"function"},{"location":"index.html#AlgebraicAgents.prewalk_ret","page":"API Documentation","title":"AlgebraicAgents.prewalk_ret","text":"Applies f to each agent. Applies f to an agent before visiting its inners. The results of each application of f are appended to a vector and returned.\n\n\n\n\n\n","category":"function"},{"location":"index.html#AlgebraicAgents.postwalk_ret","page":"API Documentation","title":"AlgebraicAgents.postwalk_ret","text":"Applies f to each agent. Applies f to an agent after visiting its inners. The results of each application of f are appended to a vector and returned.\n\n\n\n\n\n","category":"function"},{"location":"index.html#Utility-functions","page":"API Documentation","title":"Utility functions","text":"","category":"section"},{"location":"index.html#Wrap-a-dynamical-system,-extract-agent-wrap","page":"API Documentation","title":"Wrap a dynamical system, extract agent wrap","text":"","category":"section"},{"location":"index.html","page":"API Documentation","title":"API Documentation","text":"wrap_system\nextract_agent","category":"page"},{"location":"index.html#AlgebraicAgents.wrap_system","page":"API Documentation","title":"AlgebraicAgents.wrap_system","text":"wrap_system(name, system, args...; kwargs...)\n\nTypically, the function will dispatch on the type of system and initialise an algebraic agent which wraps the core dynamical system. This allows you to specify the core dynamics directly using a third-party package syntax and hide the internals on this package's side from the user.\n\nFor instance, you may define a method wrap_system(name, prob::DiffEqBase.DEProblem), which internally will invoke the constructor of DiffEqAgent.\n\nExamples\n\nwrap_system(\"ode_agent\", ODEProblem(f, u0, tspan))\nwrap_system(\"abm_agent\", ABM(agent, space; properties))\n\n\n\n\n\n","category":"function"},{"location":"index.html#AlgebraicAgents.extract_agent","page":"API Documentation","title":"AlgebraicAgents.extract_agent","text":"extract_agent\n\nExtract an agent from as a property of the dynamical system (wrapped by the agent).\n\nExamples\n\nagent = extract_agent(params) # for SciML integration\nagent = extract_agent(model, agent) # for ABM integration\n\n\n\n\n\n","category":"function"},{"location":"index.html#Flat-representation","page":"API Documentation","title":"Flat representation","text":"","category":"section"},{"location":"index.html","page":"API Documentation","title":"API Documentation","text":"flatten","category":"page"},{"location":"index.html#AlgebraicAgents.flatten","page":"API Documentation","title":"AlgebraicAgents.flatten","text":"flatten(root_agent)\n\nReturn flat representation of agents' hierarchy.\n\n\n\n\n\n","category":"function"},{"location":"index.html#Default-plots-for-custom-agent-types","page":"API Documentation","title":"Default plots for custom agent types","text":"","category":"section"},{"location":"index.html","page":"API Documentation","title":"API Documentation","text":"@draw_df","category":"page"},{"location":"index.html#AlgebraicAgents.@draw_df","page":"API Documentation","title":"AlgebraicAgents.@draw_df","text":"@draw_df T field\n\nA macro to define _draw(T) such that it will plot a DataFrame stored under field.\n\nRequires DataFrames and Plots to be available.\n\nExamples\n\n@draw_df my_type log # will plot `log` property (a DataFrame) of `my_type`'s instance\n\n\n\n\n\n","category":"macro"},{"location":"index.html#Helper-functions-for-Mermaid-diagrams","page":"API Documentation","title":"Helper functions for Mermaid diagrams","text":"","category":"section"},{"location":"index.html","page":"API Documentation","title":"API Documentation","text":"typetree_mmd\nagent_hierarchy_mmd","category":"page"},{"location":"index.html#AlgebraicAgents.typetree_mmd","page":"API Documentation","title":"AlgebraicAgents.typetree_mmd","text":"typetree_mmd(T, TT; rem = false)\n\nReturn a Vector{String} of the type hierarchy with type T, in format suitable for making Mermaid class diagrams. For the root case (where T is the top of the hierarchy), TT may be set to nothing (default argument).\n\nThe keyword argument rem can be set to true to strip the module prefix from typenames. This is useful for Mermaid diagrams, because the Mermaid classDiagram does not currently support \".\" characters in class names.\n\nExamples\n\n# the following may be pasted into the Mermaid live editor:\n# https://mermaid.live/\nprint(join(typetree_mmd(Integer), \"\"))\n\n\n\n\n\n","category":"function"},{"location":"index.html#AlgebraicAgents.agent_hierarchy_mmd","page":"API Documentation","title":"AlgebraicAgents.agent_hierarchy_mmd","text":"agent_hierarchy_mmd(a; use_uuid = 0)\n\nThis function can help display the agent hierarchy for concrete models. It assumes the user wants to pass the results into a Mermaid diagram for easier visualization of concrete model instantiations. The kwarg use_uuid will append the last use_uuid digits of each agent to their name following an underscore. This can be useful if it is not possible to distinguish unique agents purely by their name alone.\n\nExamples\n\n# the following may be pasted into the Mermaid live editor:\n# https://mermaid.live/\n\n@aagent FreeAgent struct AgentType1 end\nbase = FreeAgent(\"agent1\")\nentangle!(base, AgentType1(\"agent2\"))\nentangle!(base, AgentType1(\"agent3\"))\n\n# do not print UUIDs\nhierarchy = agent_hierarchy_mmd(base)\nprint(join(hierarchy,\"\"))\n\n# print last 4 digits of UUIDs\nhierarchy = agent_hierarchy_mmd(base, use_uuid = 4)\nprint(join(hierarchy,\"\"))\n\n\n\n\n\n","category":"function"},{"location":"index.html#Queries","page":"API Documentation","title":"Queries","text":"","category":"section"},{"location":"index.html","page":"API Documentation","title":"API Documentation","text":"It is possible to run filter and transform queries on agent hierarchies.","category":"page"},{"location":"index.html#Filter-queries","page":"API Documentation","title":"Filter queries","text":"","category":"section"},{"location":"index.html","page":"API Documentation","title":"API Documentation","text":"FilterQuery\n@f_str\n@filter\nAlgebraicAgents.filter(::AbstractAlgebraicAgent, ::FilterQuery)","category":"page"},{"location":"index.html#AlgebraicAgents.FilterQuery","page":"API Documentation","title":"AlgebraicAgents.FilterQuery","text":"FilterQuery(query)\n\nSimple property query; references agents via underscores _.\n\nA query on an agent may result in an error; in that case, the agent will fail the filter condition by default.\n\nSee also @f_str, filter.\n\nExamples\n\nfilter(agents, f\"_.age > 21 && _.name ∈ ['a', 'b']\")\nagents |> @filter _.age > 21 && _.name ∈ ['a', 'b']\n\n\n\n\n\n","category":"type"},{"location":"index.html#AlgebraicAgents.@f_str","page":"API Documentation","title":"AlgebraicAgents.@f_str","text":"f\"query\"\n\nTurn a query string into a query instance, see also FilterQuery.\n\nSupports string interpolations.\n\nExamples\n\nfilter(agents, f\"_.age > 1 && _.name ∈ ['a', 'b']\")\ni = 1; filter(agents, f\"_.age > $i && _.name ∈ ['a', 'b']\")\n\n\n\n\n\n","category":"macro"},{"location":"index.html#AlgebraicAgents.@filter","page":"API Documentation","title":"AlgebraicAgents.@filter","text":"@filter query\n\nTurn a filter query into a function of agents' hierarchy. Accepts expressions (corresponding to q-strings) and query string.\n\nSee also FilterQuery.\n\n\n\n\n\n","category":"macro"},{"location":"index.html#Base.filter-Tuple{AbstractAlgebraicAgent, FilterQuery}","page":"API Documentation","title":"Base.filter","text":"filter(agent::AbstractAlgebraicAgent, queries...)\nfilter(agents::Vector{<:AbstractAlgebraicAgent}, queries...)\n\nRun filter query on agents in a hierarchy.\n\nExamples\n\nfilter(agent, f\"_.age > 21 && _.name ∈ ['a', 'b']\") # filter query\n\n\n\n\n\n","category":"method"},{"location":"index.html","page":"API Documentation","title":"API Documentation","text":"To provide custom filter query types, you need to implement AlgebraicAgents._filter low-level matching method.","category":"page"},{"location":"index.html","page":"API Documentation","title":"API Documentation","text":"AlgebraicAgents._filter","category":"page"},{"location":"index.html#AlgebraicAgents._filter","page":"API Documentation","title":"AlgebraicAgents._filter","text":"_filter(agent, query)\n\nCheck if an agent satisfies filter condition.\n\n\n\n\n\n","category":"function"},{"location":"index.html#Transform-queries","page":"API Documentation","title":"Transform queries","text":"","category":"section"},{"location":"index.html","page":"API Documentation","title":"API Documentation","text":"TransformQuery\n@transform\ntransform","category":"page"},{"location":"index.html#AlgebraicAgents.TransformQuery","page":"API Documentation","title":"AlgebraicAgents.TransformQuery","text":"TransformQuery(name, query)\n\nSimple transform query; references agents via underscores _.\n\nSee also @transform.\n\nExamples\n\nagent |> @transform(name=_.name)\nagent |> @transform(name=_.name, _.age)\n\n\n\n\n\n","category":"type"},{"location":"index.html#AlgebraicAgents.@transform","page":"API Documentation","title":"AlgebraicAgents.@transform","text":"@transform queries...\n\nTurn transform queries into an anonymous function of agents' hierarchy. See also TransformQuery.\n\nAccepts both anonymous queries (_.name) and named queries (name=_.name). By default, includes agent's uuid.\n\n\n\n\n\n","category":"macro"},{"location":"index.html#AlgebraicAgents.transform","page":"API Documentation","title":"AlgebraicAgents.transform","text":"transform(agent::AbstractAlgebraicAgent, queries...)\ntranform(agent::Vector{<:AbstractAlgebraicAgent}, queries...)\n\nRun transform query on agents in a hierarchy.\n\nA query on an agent may result in an error; in that case, the respective agent's output is omitted for the result.\n\nSee also @transform.\n\nExamples\n\nagent |> @transform(name=_.name)\nagent |> @transform(name=_.name, _.age)\n\n\n\n\n\n","category":"function"},{"location":"integrations.html#Integrations","page":"Integrations","title":"Integrations","text":"","category":"section"},{"location":"integrations.html#SciML-Integration","page":"Integrations","title":"SciML Integration","text":"","category":"section"},{"location":"integrations.html#Agent-Constructors","page":"Integrations","title":"Agent Constructors","text":"","category":"section"},{"location":"integrations.html","page":"Integrations","title":"Integrations","text":"DiffEqAgent","category":"page"},{"location":"integrations.html#AlgebraicAgents.DiffEqAgent","page":"Integrations","title":"AlgebraicAgents.DiffEqAgent","text":"DiffEqAgent(name, problem[, alg]; observables=nothing, kwargs...)\n\nInitialize DE problem algebraic wrap. \n\nKeywords\n\nobservables: either nothing or a dictionary which maps keys to observable's positional index in u,\nother kwargs will be passed to the integrator during initialization step.\n\n\n\n\n\n","category":"type"},{"location":"integrations.html#AlgebraicDynamics.jl-Integration","page":"Integrations","title":"AlgebraicDynamics.jl Integration","text":"","category":"section"},{"location":"integrations.html#Agent-Constructors-2","page":"Integrations","title":"Agent Constructors","text":"","category":"section"},{"location":"integrations.html","page":"Integrations","title":"Integrations","text":"GraphicalAgent","category":"page"},{"location":"integrations.html#AlgebraicAgents.GraphicalAgent","page":"Integrations","title":"AlgebraicAgents.GraphicalAgent","text":"GraphicalAgent(name, model)\n\nInitialize algebraic wrap of either an AbstractResourceSharer or a AbstractMachine.\n\nThe wrapped AbstractResourceSharer or AbstractMachine is stored as the property system.\n\nExamples\n\nGraphicalAgent(\"rabbit\", ContinuousMachine{Float64}(1,1,1, dotr, (u, p, t) -> u))\n\n\n\n\n\n","category":"type"},{"location":"integrations.html#Conversion-to-DiffEqAgent","page":"Integrations","title":"Conversion to DiffEqAgent","text":"","category":"section"},{"location":"integrations.html","page":"Integrations","title":"Integrations","text":"DiffEqAgent(::GraphicalAgent, args...)","category":"page"},{"location":"integrations.html#AlgebraicAgents.DiffEqAgent-Tuple{GraphicalAgent, Vararg{Any}}","page":"Integrations","title":"AlgebraicAgents.DiffEqAgent","text":"DiffEqAgent(agent::GraphicalAgent, u0, tspan, p; alg, kwargs...)\n\nInfer a problem type parametrized by agent.system, and create an appropriate DEProblem. Moreover, wrap this problem as an instance of DiffEqAgent; this contains agent's inner hierarchy.\n\nExamples\n\nDiffEqAgent(system, u0, tspan, params)\nDiffEqAgent(system, u0, tspan, params; alg=Tsit5())\n\n\n\n\n\n","category":"method"},{"location":"integrations.html#Sums","page":"Integrations","title":"Sums","text":"","category":"section"},{"location":"integrations.html","page":"Integrations","title":"Integrations","text":"⊕(::GraphicalAgent)","category":"page"},{"location":"integrations.html#AlgebraicAgents.:⊕-Tuple{GraphicalAgent}","page":"Integrations","title":"AlgebraicAgents.:⊕","text":"⊕(system1, system2; diagram=pattern, name)\n⊕([system1, system2]; diagram=pattern, name)\n⊕(Dict(:system1 => system1, :system2 => system2); diagram=pattern, name)\n\nApply oapply(diagram, systems...) and wrap the result as a GraphicalAgent.\n\n\n\n\n\n","category":"method"},{"location":"integrations.html#Agents.jl-Integration","page":"Integrations","title":"Agents.jl Integration","text":"","category":"section"},{"location":"integrations.html","page":"Integrations","title":"Integrations","text":"The integration can be loaded as:","category":"page"},{"location":"integrations.html#Agent-Constructors-3","page":"Integrations","title":"Agent Constructors","text":"","category":"section"},{"location":"integrations.html","page":"Integrations","title":"Integrations","text":"ABMAgent\nAAgent","category":"page"},{"location":"integrations.html#AlgebraicAgents.ABMAgent","page":"Integrations","title":"AlgebraicAgents.ABMAgent","text":"ABMAgent(name, abm; kwargs...)\n\nInitialize ABMAgent, incl. hierarchy of ABM's agents.\n\nConfigure the evolutionary step, logging, and step size by keyword arguments below.\n\nArguments\n\n- `agent_step!`, `model_step!`: same meaning as in `Agents.step!`\n- in general, any kwarg accepted by `Agents.run!`, incl. `adata`, `mdata`\n- `when`, `when_model`: when to collect agents data, model data\ntrue by default, and performs data collection at every step\nif an `AbstractVector`, checks if `t ∈ when`; otherwise a function (model, t) -> ::Bool\n- `step_size`: how far the step advances, either a float or a function (model, t) -> size::Float64\n- `tspan`: solution horizon, defaults to `(0., Inf)`\n\n\n\n\n\n","category":"type"},{"location":"integrations.html#AlgebraicAgents.AAgent","page":"Integrations","title":"AlgebraicAgents.AAgent","text":"Algebraic wrap for AbstractAgent type.\n\n\n\n\n\n","category":"type"},{"location":"integrations.html#Bindings","page":"Integrations","title":"Bindings","text":"","category":"section"},{"location":"integrations.html","page":"Integrations","title":"Integrations","text":"@a","category":"page"},{"location":"integrations.html#AlgebraicAgents.@a","page":"Integrations","title":"AlgebraicAgents.@a","text":"@a operation\n\nAlgebraic extension of add_agent!, kill_agent!.\n\nExamples\n\n@a add_agent!(model, 0.5)\n@a disentangle!(agent, model)\n\n\n\n\n\n","category":"macro"},{"location":"sketches/molecules/molecules.html","page":"A Toy Pharma Model","title":"A Toy Pharma Model","text":"EditURL = \"https://github.com/Merck/AlgebraicAgents.jl/blob/main/tutorials/molecules/molecules.jl\"","category":"page"},{"location":"sketches/molecules/molecules.html#A-Toy-Pharma-Model","page":"A Toy Pharma Model","title":"A Toy Pharma Model","text":"","category":"section"},{"location":"sketches/molecules/molecules.html","page":"A Toy Pharma Model","title":"A Toy Pharma Model","text":"We implement a toy pharma model. To that end, we have the following type hierarchy:","category":"page"},{"location":"sketches/molecules/molecules.html","page":"A Toy Pharma Model","title":"A Toy Pharma Model","text":"overarching pharma model (represented by a FreeAgent span type),\ntherapeutic area (represented by a FreeAgent),\nmolecules (small, large - to demonstrate dynamic dispatch; alternatively, marketed drugs; a drug may drop out from the system),\ndiscovery unit (per therapeutic area); these generate new molecules according to a Poisson counting process,\nmarket demand; this will be represented by a stochastic differential equation implemented in DifferentialEquations.jl.","category":"page"},{"location":"sketches/molecules/molecules.html#Agent-Types","page":"A Toy Pharma Model","title":"Agent Types","text":"","category":"section"},{"location":"sketches/molecules/molecules.html","page":"A Toy Pharma Model","title":"A Toy Pharma Model","text":"We define the type system and supply the stepping functions.","category":"page"},{"location":"sketches/molecules/molecules.html","page":"A Toy Pharma Model","title":"A Toy Pharma Model","text":"using AlgebraicAgents\n\nusing DataFrames\nusing Distributions, Random\nusing Plots\n\n# type hierarchy\n\"Drug entity, lives in a therapeutic area.\"\nabstract type Molecule <: AbstractAlgebraicAgent end\n\n# molecule params granularity\nconst N = 3;\n\n# drug entity, lives in a therapeutic area\n\"Parametrized drug entity, lives in a therapeutic area.\"\n@aagent FreeAgent Molecule struct SmallMolecule\n    age::Float64\n    birth_time::Float64\n    time_removed::Float64\n\n    mol::AbstractString\n    profile::NTuple{N, Float64}\n\n    sales::Float64\n    df_sales::DataFrame\nend","category":"page"},{"location":"sketches/molecules/molecules.html","page":"A Toy Pharma Model","title":"A Toy Pharma Model","text":"Note the use of a conveniency macro @aagent which appends additional fields expected (not required, though) by default interface methods.","category":"page"},{"location":"sketches/molecules/molecules.html","page":"A Toy Pharma Model","title":"A Toy Pharma Model","text":"We proceed with other agent types.","category":"page"},{"location":"sketches/molecules/molecules.html","page":"A Toy Pharma Model","title":"A Toy Pharma Model","text":"# drug entity, lives in a therapeutic area\n@doc (@doc SmallMolecule)\n@aagent FreeAgent Molecule struct LargeMolecule\n    age::Float64\n    birth_time::Float64\n    time_removed::Float64\n\n    mol::AbstractString\n    profile::NTuple{N, Float64}\n\n    sales::Float64\n    df_sales::DataFrame\nend\n\n# toy discovery unit - outputs small/large molecules to a given therapeutic area\n\"Toy discovery unit; outputs small and large molecules.\"\n@aagent struct Discovery\n    rate_small::Float64\n    rate_large::Float64\n    discovery_intensity::Float64\n\n    t::Float64\n    dt::Float64\n\n    t0::Float64\n\n    removed_mols::Vector{Tuple{String, Float64}}\n\n    df_output::DataFrame\nend\n\n# `Discovery` constructor\n\"Initialize a discovery unit, parametrized by small/large molecules production rate.\"\nfunction Discovery(name, rate_small, rate_large, t = 0.0; dt = 2.0)\n    df_output = DataFrame(time = Float64[], small = Int[], large = Int[], removed = Int[])\n\n    Discovery(name, rate_small, rate_large, 0.0, t, dt, t, Tuple{String, Float64}[],\n              df_output)\nend","category":"page"},{"location":"sketches/molecules/molecules.html#Stepping-Functions","page":"A Toy Pharma Model","title":"Stepping Functions","text":"","category":"section"},{"location":"sketches/molecules/molecules.html","page":"A Toy Pharma Model","title":"A Toy Pharma Model","text":"Next we provide an evolutionary law for the agent types. This is done by extending the interface function AlgebraicAgents._step!.","category":"page"},{"location":"sketches/molecules/molecules.html","page":"A Toy Pharma Model","title":"A Toy Pharma Model","text":"# Return initial sales volume of a molecule.\nfunction sales0_from_params end\n\nconst sales0_factor_small = rand(N)\nconst sales0_factor_large = rand(N)\n\n# dispatch on molecule type\nsales0_from_params(profile) = 10^3 * (1 + collect(profile)' * sales0_factor_small)\nsales0_from_params(profile) = 10^5 * (1 + collect(profile)' * sales0_factor_large)\n\nconst sales_decay_small = 0.9\nconst sales_decay_large = 0.7\n\n# implement evolution\nfunction AlgebraicAgents._step!(mol::SmallMolecule)\n    t = projected_to(mol)\n    push!(mol.df_sales, (t, mol.sales))\n    mol.age += 1\n    mol.sales *= sales_decay_small\n\n    if (mol.sales <= 10) || (rand() >= exp(-0.2 * mol.age))\n        mol.time_removed = t\n        push!(getagent(mol, \"../dx\").removed_mols, (mol.mol, t))\n\n        # move to removed candidates\n        rm_mols = getagent(mol, \"../removed-molecules\")\n        disentangle!(mol)\n        entangle!(rm_mols, mol)\n    end\nend\n\n# implement common interface\"\n# molecules\"\nfunction AlgebraicAgents._step!(mol::LargeMolecule)\n    t = projected_to(mol)\n    push!(mol.df_sales, (t, mol.sales))\n\n    mol.age += 1\n    mol.sales *= sales_decay_large\n\n    if (mol.sales <= 10) || (rand() >= exp(-0.3 * mol.age))\n        mol.time_removed = t\n        push!(getagent(mol, \"../dx\").removed_mols, (mol.mol, t))\n\n        # move to removed candidates\n        rm_mols = getagent(mol, \"../removed-molecules\")\n        disentangle!(mol)\n        entangle!(rm_mols, mol)\n    end\nend\n\n# discovery\nfunction AlgebraicAgents._step!(dx::Discovery)\n    t = projected_to(dx)\n    # sync with market demand\n    dx.discovery_intensity = getobservable(getagent(dx, \"../demand\"), \"demand\")\n    ν = dx.discovery_intensity * dx.dt\n    small, large = rand(Poisson(ν * dx.rate_small)), rand(Poisson(ν * dx.rate_large))\n    removeed = 0\n    ix = 1\n    while ix <= length(dx.removed_mols)\n        if (dx.removed_mols[ix][2] < t)\n            removeed += 1\n            deleteat!(dx.removed_mols, ix)\n        else\n            ix += 1\n        end\n    end\n    push!(dx.df_output, (t, small, large, removeed))\n\n    for _ in 1:small\n        mol = release_molecule(randstring(5), Tuple(rand(N)), t, SmallMolecule)\n        entangle!(getparent(dx), mol)\n    end\n\n    for _ in 1:large\n        mol = release_molecule(randstring(5), Tuple(rand(N)), t, LargeMolecule)\n        entangle!(getparent(dx), mol)\n    end\n\n    dx.t += dx.dt\nend\n\n\"Initialize a new molecule.\"\nfunction release_molecule(mol, profile, t, ::Type{T}) where {T <: Molecule}\n    T(mol, 0.0, t, Inf, mol, profile, sales0_from_params(profile),\n      DataFrame(time = Float64[], sales = Float64[]))\nend","category":"page"},{"location":"sketches/molecules/molecules.html","page":"A Toy Pharma Model","title":"A Toy Pharma Model","text":"We provide additional interface methods, such as AlgebraicAgents._reinit! and AlgebraicAgents._projected_to.","category":"page"},{"location":"sketches/molecules/molecules.html","page":"A Toy Pharma Model","title":"A Toy Pharma Model","text":"AlgebraicAgents._reinit!(mol::Molecule) = disentangle!(mol)\n\nfunction AlgebraicAgents._reinit!(dx::Discovery)\n    dx.t = dx.t0\n    dx.discovery_intensity = 0.0\n    empty!(dx.df_output)\n\n    dx\nend\n\nfunction AlgebraicAgents._projected_to(mol::Molecule)\n    if mol.time_removed < Inf\n        # candidate removed, do not step further\n        true\n    else\n        mol.age + mol.birth_time\n    end\nend\n\nAlgebraicAgents._projected_to(dx::Discovery) = dx.t","category":"page"},{"location":"sketches/molecules/molecules.html","page":"A Toy Pharma Model","title":"A Toy Pharma Model","text":"We may also provide a custom plotting recipe. As the internal log is modeled as a DataFrame, we want to use AlgebraicAgents.@draw_df convenience macro.","category":"page"},{"location":"sketches/molecules/molecules.html","page":"A Toy Pharma Model","title":"A Toy Pharma Model","text":"# implement plots\nAlgebraicAgents.@draw_df Discovery df_output","category":"page"},{"location":"sketches/molecules/molecules.html#Model-Instantiation","page":"A Toy Pharma Model","title":"Model Instantiation","text":"","category":"section"},{"location":"sketches/molecules/molecules.html","page":"A Toy Pharma Model","title":"A Toy Pharma Model","text":"Next step is to instantiate a dynamical system.","category":"page"},{"location":"sketches/molecules/molecules.html","page":"A Toy Pharma Model","title":"A Toy Pharma Model","text":"# define therapeutic areas\ntherapeutic_area1 = FreeAgent(\"therapeutic_area1\")\ntherapeutic_area2 = FreeAgent(\"therapeutic_area2\")\n\n# join therapeutic models into a pharma model\npharma_model = ⊕(therapeutic_area1, therapeutic_area2; name=\"pharma_model\")\n\n# initialize and push discovery units to therapeutic areas\n# discovery units evolve at different pace\nentangle!(therapeutic_area1, Discovery(\"dx\", 5.2, 10.; dt=3.))\nentangle!(therapeutic_area2, Discovery(\"dx\", 6., 8.; dt=5.))\n# log removed candidates\nentangle!(therapeutic_area1, FreeAgent(\"removed-molecules\"))\nentangle!(therapeutic_area2, FreeAgent(\"removed-molecules\"))","category":"page"},{"location":"sketches/molecules/molecules.html#Integration-with-SciML","page":"A Toy Pharma Model","title":"Integration with SciML","text":"","category":"section"},{"location":"sketches/molecules/molecules.html","page":"A Toy Pharma Model","title":"A Toy Pharma Model","text":"Let's define toy market demand model and represent this as a stochastic differential equation defined in DifferentialEquations.jl","category":"page"},{"location":"sketches/molecules/molecules.html","page":"A Toy Pharma Model","title":"A Toy Pharma Model","text":"# add SDE models for drug demand in respective areas\nusing DifferentialEquations\n\ndt = 1//2^(4); tspan = (0.0,100.)\nf(u,p,t) = p[1]*u; g(u,p,t) = p[2]*u\n\nprob_1 = SDEProblem(f,g,.9,tspan,[.01, .01])\nprob_2 = SDEProblem(f,g,1.2,tspan,[.01, .01])","category":"page"},{"location":"sketches/molecules/molecules.html","page":"A Toy Pharma Model","title":"A Toy Pharma Model","text":"Internally, a discovery unit will adjust the candidate generating process intensity according to the observed market demand:","category":"page"},{"location":"sketches/molecules/molecules.html","page":"A Toy Pharma Model","title":"A Toy Pharma Model","text":"# add SDE models for drug demand in respective areas\ndemand_model_1 = DiffEqAgent(\"demand\", prob_1, EM(); observables=Dict(\"demand\" => 1), dt)\ndemand_model_2 = DiffEqAgent(\"demand\", prob_2, EM(); observables=Dict(\"demand\" => 1), dt)\n\n# push market demand units to therapeutic areas\nentangle!(therapeutic_area1, demand_model_1)\nentangle!(therapeutic_area2, demand_model_2)\n\n# sync with market demand\ngetobservable(getagent(pharma_model, \"therapeutic_area1/demand\"), \"demand\")","category":"page"},{"location":"sketches/molecules/molecules.html","page":"A Toy Pharma Model","title":"A Toy Pharma Model","text":"Let's inspect the composite model:","category":"page"},{"location":"sketches/molecules/molecules.html","page":"A Toy Pharma Model","title":"A Toy Pharma Model","text":"# show the model\npharma_model","category":"page"},{"location":"sketches/molecules/molecules.html","page":"A Toy Pharma Model","title":"A Toy Pharma Model","text":"getagent(pharma_model, glob\"therapeutic_area?/\")","category":"page"},{"location":"sketches/molecules/molecules.html#Simulating-the-System","page":"A Toy Pharma Model","title":"Simulating the System","text":"","category":"section"},{"location":"sketches/molecules/molecules.html","page":"A Toy Pharma Model","title":"A Toy Pharma Model","text":"Let's next evolve the composite model over a hundred time units. The last argument is optional here; see ?simulate for the details.","category":"page"},{"location":"sketches/molecules/molecules.html","page":"A Toy Pharma Model","title":"A Toy Pharma Model","text":"# let the problem evolve\nsimulate(pharma_model, 100)\n\ngetagent(pharma_model, \"therapeutic_area1/dx\")\n\ngetagent(pharma_model, \"therapeutic_area1/demand\")","category":"page"},{"location":"sketches/molecules/molecules.html#Plotting","page":"A Toy Pharma Model","title":"Plotting","text":"","category":"section"},{"location":"sketches/molecules/molecules.html","page":"A Toy Pharma Model","title":"A Toy Pharma Model","text":"We draw the statistics of a Discovery unit in Therapeutic Area 1:","category":"page"},{"location":"sketches/molecules/molecules.html","page":"A Toy Pharma Model","title":"A Toy Pharma Model","text":"draw(getagent(pharma_model, \"therapeutic_area1/dx\"))","category":"page"},{"location":"sketches/molecules/molecules.html#Queries","page":"A Toy Pharma Model","title":"Queries","text":"","category":"section"},{"location":"sketches/molecules/molecules.html","page":"A Toy Pharma Model","title":"A Toy Pharma Model","text":"Let's now query the simulated system.","category":"page"},{"location":"sketches/molecules/molecules.html","page":"A Toy Pharma Model","title":"A Toy Pharma Model","text":"To find out which molecules were discovered after time t=10 and removed from the track before time t=30, write","category":"page"},{"location":"sketches/molecules/molecules.html","page":"A Toy Pharma Model","title":"A Toy Pharma Model","text":"pharma_model |> @filter(_.birth_time > 10 && _.time_removed < 30)","category":"page"},{"location":"sketches/molecules/molecules.html","page":"A Toy Pharma Model","title":"A Toy Pharma Model","text":"Equivalently, we could make use of f(ilter)-strings, see @f_str, and write","category":"page"},{"location":"sketches/molecules/molecules.html","page":"A Toy Pharma Model","title":"A Toy Pharma Model","text":"from = 10; to = 30\npharma_model |> @filter(f\"_.birth_time > $from && _.time_removed < $to\");\nnothing #hide","category":"page"},{"location":"sketches/molecules/molecules.html","page":"A Toy Pharma Model","title":"A Toy Pharma Model","text":"Let's investigate the average life time:","category":"page"},{"location":"sketches/molecules/molecules.html","page":"A Toy Pharma Model","title":"A Toy Pharma Model","text":"# get molecules already removed from the system\nremoved_molecules = pharma_model |> @filter(f\"_.time_removed < Inf\")\n# calculate `time_removed - birth_time`\n# we iterate over `removed_molecules`, and apply the (named) transform function on each agent\n# a given agent is referenced to as `_`\nlife_times = removed_molecules |> @transform(area = getname(getagent(_, \"../..\")), time=(_.time_removed - _.birth_time))\n\nusing Statistics: mean\navg_life_time = mean(x -> x.time, life_times)","category":"page"}]
}
