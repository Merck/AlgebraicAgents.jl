var documenterSearchIndex = {"docs":
[{"location":"sketches/pharma.html#A-Toy-Pharma-Model","page":"A Toy Pharma Model","title":"A Toy Pharma Model","text":"","category":"section"},{"location":"sketches/pharma.html","page":"A Toy Pharma Model","title":"A Toy Pharma Model","text":"We implement a toy pharma model. To that end, we have the following type hierarchy:","category":"page"},{"location":"sketches/pharma.html","page":"A Toy Pharma Model","title":"A Toy Pharma Model","text":"overarching pharma model (represented by a FreeAgent span type),\ntherapeutic area (represented by a FreeAgent), \nmolecules (small, large - to demonstrate dynamic dispatch; alternatively, marketed drugs; a drug may drop out from the system,\ndiscovery unit (per therapeutic area); these generate new molecules according to a Poisson counting process,\nmarket demand; this will be represented by a stochastic differential equation implemented in DifferentialEquations.jl.","category":"page"},{"location":"sketches/pharma.html","page":"A Toy Pharma Model","title":"A Toy Pharma Model","text":"The next step is to define the molecules and discovery units types. This is done in there; here we sketch an implementation of SmallMolecule <: Molecule <: AbstractAlgebraicAgent type.","category":"page"},{"location":"sketches/pharma.html","page":"A Toy Pharma Model","title":"A Toy Pharma Model","text":"using AlgebraicAgents\ninclude(\"../../../tutorials/molecules/types.jl\")","category":"page"},{"location":"sketches/pharma.html#Integrating-a-Custom-Dynamical-System","page":"A Toy Pharma Model","title":"Integrating a Custom Dynamical System","text":"","category":"section"},{"location":"sketches/pharma.html","page":"A Toy Pharma Model","title":"A Toy Pharma Model","text":"# drug entity, lives in a therapeutic area \n@aagent FreeAgent Molecule struct SmallMolecule\n    age::Float64\n    birth_time::Float64\n    kill_time::Float64\n\n    mol::AbstractString\n    profile::NTuple{N, Float64}\n\n    sales::Float64\n    df_sales::DataFrame\nend","category":"page"},{"location":"sketches/pharma.html","page":"A Toy Pharma Model","title":"A Toy Pharma Model","text":"Note the use of a conveniency macro @aagent which appends additional fields expected (not required, though) by default interface methods.","category":"page"},{"location":"sketches/pharma.html","page":"A Toy Pharma Model","title":"A Toy Pharma Model","text":"Next we provide an evolutionary law for SmallMolecule type. This is done by extending the interface function AlgebraicAgents._step!.","category":"page"},{"location":"sketches/pharma.html","page":"A Toy Pharma Model","title":"A Toy Pharma Model","text":"# implement evolution\nfunction AlgebraicAgents._step!(mol::SmallMolecule)\n    t = projected_to(mol) # get current time; this equals the time point up to which the mol agent has been projected (enforced via `AlgebraicAgents.step!`)\n    # log sales volume at time t\n    push!(mol.df_sales, (t, mol.sales))\n    # increment mol's age - by default, mols will evolve by unit step\n    mol.age += 1\n    # apply sales decay in time \n    mol.sales *= sales_decay_small\n\n    # remove mol 1) once sales volume drops below a given level\n    # 2) also account for some random effect - prob of removal increases in time\n    if (mol.sales <= 10) || (rand() >= exp(-0.2*mol.age))\n        mol.kill_time = t\n        push!(getagent(mol, \"../dx\").removed_mols, (mol.mol, t))\n        # remove mol from the system\n        disentangle!(mol)\n    end\nend","category":"page"},{"location":"sketches/pharma.html","page":"A Toy Pharma Model","title":"A Toy Pharma Model","text":"We provide additional methods required by the common interface:","category":"page"},{"location":"sketches/pharma.html","page":"A Toy Pharma Model","title":"A Toy Pharma Model","text":"# to reinit the system's state - since we have cold starts here, let's simply remove the mol\nAlgebraicAgents._reinit!(mol::Molecule) = disentangle!(mol)\n# return time to which the system has been projected\nAlgebraicAgents._projected_to(mol::Molecule) = mol.age + mol.birth_time","category":"page"},{"location":"sketches/pharma.html#Adding-SDE-Models","page":"A Toy Pharma Model","title":"Adding SDE Models","text":"","category":"section"},{"location":"sketches/pharma.html","page":"A Toy Pharma Model","title":"A Toy Pharma Model","text":"Let's define toy market demand model and represent this as a stochastic differential equation defined in DifferentialEquations.jl","category":"page"},{"location":"sketches/pharma.html","page":"A Toy Pharma Model","title":"A Toy Pharma Model","text":"# add SDE models for drug demand in respective areas\nusing DifferentialEquations\n\ndt = 1//2^(4); tspan = (0.0,100.)\nf(u,p,t) = p[1]*u; g(u,p,t) = p[2]*u\n\nprob_1 = SDEProblem(f,g,.9,tspan,[.01, .01])\nprob_2 = SDEProblem(f,g,1.2,tspan,[.01, .01])","category":"page"},{"location":"sketches/pharma.html","page":"A Toy Pharma Model","title":"A Toy Pharma Model","text":"Internally, a discovery unit will adjust its productivity according to the observed market demand:","category":"page"},{"location":"sketches/pharma.html","page":"A Toy Pharma Model","title":"A Toy Pharma Model","text":"# sync with market demand\ndx.productivity, = @observables dx \"../demand\":\"demand\"","category":"page"},{"location":"sketches/pharma.html#Defining-and-Entangling-the-Systems","page":"A Toy Pharma Model","title":"Defining & Entangling the Systems","text":"","category":"section"},{"location":"sketches/pharma.html","page":"A Toy Pharma Model","title":"A Toy Pharma Model","text":"Next step is to initiate the actual dynamical systems.","category":"page"},{"location":"sketches/pharma.html","page":"A Toy Pharma Model","title":"A Toy Pharma Model","text":"# define therapeutic areas\ntherapeutic_area1 = FreeAgent(\"therapeutic_area1\")\ntherapeutic_area2 = FreeAgent(\"therapeutic_area2\")\n\n# join therapeutic models into a pharma model\npharma_model = ⊕(therapeutic_area1, therapeutic_area2; name=\"pharma_model\")\n\n# initialize and push discovery units to therapeutic areas\n# discovery units evolve at different pace\nentangle!(therapeutic_area1, Discovery(\"dx\", 5.2, 10.; dt=3.))\nentangle!(therapeutic_area2, Discovery(\"dx\", 6., 8.; dt=5.))\n\n# add SDE models for drug demand in respective areas\ndemand_model_1 = DiffEqAgent(\"demand\", prob_1, EM(); exposed_ports=Dict(\"demand\" => 1), dt)\ndemand_model_2 = DiffEqAgent(\"demand\", prob_2, EM(); exposed_ports=Dict(\"demand\" => 1), dt)\n\n# push market demand units to therapeutic areas\nentangle!(therapeutic_area1, demand_model_1)\nentangle!(therapeutic_area2, demand_model_2)\n\n# show the model\npharma_model","category":"page"},{"location":"sketches/pharma.html","page":"A Toy Pharma Model","title":"A Toy Pharma Model","text":"getagent(pharma_model, glob\"therapeutic_area?/\")","category":"page"},{"location":"sketches/pharma.html#Simulating-the-System","page":"A Toy Pharma Model","title":"Simulating the System","text":"","category":"section"},{"location":"sketches/pharma.html","page":"A Toy Pharma Model","title":"A Toy Pharma Model","text":"Let's next evolve the compound model over a hundred time units. The last argument is optional here; see ?simulate for the details.","category":"page"},{"location":"sketches/pharma.html","page":"A Toy Pharma Model","title":"A Toy Pharma Model","text":"# let the problem evolve\nsimulate(pharma_model, 100)","category":"page"},{"location":"sketches/pharma.html","page":"A Toy Pharma Model","title":"A Toy Pharma Model","text":"getagent(pharma_model, \"therapeutic_area1/dx\")","category":"page"},{"location":"sketches/pharma.html","page":"A Toy Pharma Model","title":"A Toy Pharma Model","text":"getagent(pharma_model, \"therapeutic_area1/demand\")","category":"page"},{"location":"sketches/pharma.html#Plotting","page":"A Toy Pharma Model","title":"Plotting","text":"","category":"section"},{"location":"sketches/pharma.html","page":"A Toy Pharma Model","title":"A Toy Pharma Model","text":"It's possible to provide custom plotting recipes by specializing the interface method AlgebraicAgents._draw(agent). Whenever a dynamical system's state is logged into a single DataFrame - as is the case with Discovery type - you may utilize a convenience macro @draw_df. To that end, we need to load DataFrames and Plots.","category":"page"},{"location":"sketches/pharma.html","page":"A Toy Pharma Model","title":"A Toy Pharma Model","text":"# implement plots\nusing DataFrames, Plots\nAlgebraicAgents.@draw_df Discovery df_output","category":"page"},{"location":"sketches/pharma.html","page":"A Toy Pharma Model","title":"A Toy Pharma Model","text":"To see this in action, call","category":"page"},{"location":"sketches/pharma.html","page":"A Toy Pharma Model","title":"A Toy Pharma Model","text":"draw(getagent(pharma_model, \"therapeutic_area1/dx\"))","category":"page"},{"location":"sketches/pharma.html","page":"A Toy Pharma Model","title":"A Toy Pharma Model","text":"(Image: plot)","category":"page"},{"location":"sketches/algebraicdynamics.html#Lotka-Voltera-Two-Ways","page":"Lotka-Voltera Two Ways","title":"Lotka-Voltera Two Ways","text":"","category":"section"},{"location":"sketches/algebraicdynamics.html","page":"Lotka-Voltera Two Ways","title":"Lotka-Voltera Two Ways","text":"We showcase the integration of AlgebraicDynamics.jl, we adopt Lotka-Volterra Three Ways tutorial.","category":"page"},{"location":"sketches/algebraicdynamics.html#Undirected-Composition","page":"Lotka-Voltera Two Ways","title":"Undirected Composition","text":"","category":"section"},{"location":"sketches/algebraicdynamics.html","page":"Lotka-Voltera Two Ways","title":"Lotka-Voltera Two Ways","text":"using AlgebraicDynamics\nusing AlgebraicDynamics.UWDDynam\nusing Catlab.WiringDiagrams, Catlab.Programs\nusing LabelledArrays\nusing Plots\n\nconst UWD = UndirectedWiringDiagram","category":"page"},{"location":"sketches/algebraicdynamics.html","page":"Lotka-Voltera Two Ways","title":"Lotka-Voltera Two Ways","text":"using AlgebraicAgents","category":"page"},{"location":"sketches/algebraicdynamics.html","page":"Lotka-Voltera Two Ways","title":"Lotka-Voltera Two Ways","text":"# Define the primitive systems\ndotr(u,p,t) = p.α*u\ndotrf(u,p,t) = [-p.β*u[1]*u[2], p.γ*u[1]*u[2]]\ndotf(u,p,t) = -p.δ*u","category":"page"},{"location":"sketches/algebraicdynamics.html","page":"Lotka-Voltera Two Ways","title":"Lotka-Voltera Two Ways","text":"rabbit_growth = @wrap rabbit_growth ContinuousResourceSharer{Float64}(1, dotr)\nrabbitfox_predation = @wrap \"rabbitfox_predation\" ContinuousResourceSharer{Float64}(2, dotrf)\nfox_decline = @wrap \"fox_decline\" ContinuousResourceSharer{Float64}(1, dotf)","category":"page"},{"location":"sketches/algebraicdynamics.html","page":"Lotka-Voltera Two Ways","title":"Lotka-Voltera Two Ways","text":"# Define the composition pattern\nrf = @relation (rabbits,foxes) begin\n    growth(rabbits)\n    predation(rabbits,foxes)\n    decline(foxes)\nend","category":"page"},{"location":"sketches/algebraicdynamics.html","page":"Lotka-Voltera Two Ways","title":"Lotka-Voltera Two Ways","text":"# Compose\nrabbitfox_system = ⊕(rabbit_growth, rabbitfox_predation, fox_decline, diagram=rf, name=\"rabbitfox_system\")","category":"page"},{"location":"sketches/algebraicdynamics.html","page":"Lotka-Voltera Two Ways","title":"Lotka-Voltera Two Ways","text":"# Solve and plot\nu0 = [10.0, 100.0]\nparams = LVector(α=.3, β=0.015, γ=0.015, δ=0.7)\ntspan = (0.0, 100.0)","category":"page"},{"location":"sketches/algebraicdynamics.html","page":"Lotka-Voltera Two Ways","title":"Lotka-Voltera Two Ways","text":"import DifferentialEquations\nprob = DiffEqAgent(rabbitfox_system, u0, tspan, params)","category":"page"},{"location":"sketches/algebraicdynamics.html","page":"Lotka-Voltera Two Ways","title":"Lotka-Voltera Two Ways","text":"sol = simulate(prob)","category":"page"},{"location":"sketches/algebraicdynamics.html","page":"Lotka-Voltera Two Ways","title":"Lotka-Voltera Two Ways","text":"draw(sol; label=[\"rabbits\" \"foxes\"])","category":"page"},{"location":"sketches/algebraicdynamics.html#Directed-Composition","page":"Lotka-Voltera Two Ways","title":"Directed Composition","text":"","category":"section"},{"location":"sketches/algebraicdynamics.html","page":"Lotka-Voltera Two Ways","title":"Lotka-Voltera Two Ways","text":"using AlgebraicDynamics, AlgebraicDynamics.DWDDynam\nusing Catlab.WiringDiagrams, Catlab.Programs\nusing LabelledArrays\nusing Plots","category":"page"},{"location":"sketches/algebraicdynamics.html","page":"Lotka-Voltera Two Ways","title":"Lotka-Voltera Two Ways","text":"using AlgebraicAgents, DifferentialEquations","category":"page"},{"location":"sketches/algebraicdynamics.html","page":"Lotka-Voltera Two Ways","title":"Lotka-Voltera Two Ways","text":"# Define the primitive systems\ndotr(u, x, p, t) = [p.α*u[1] - p.β*u[1]*x[1]]\ndotf(u, x, p, t) = [p.γ*u[1]*x[1] - p.δ*u[1]]\n\nrabbit = @wrap rabbit ContinuousMachine{Float64}(1,1,1, dotr, (u, p, t) -> u)\nfox    = @wrap fox ContinuousMachine{Float64}(1,1,1, dotf, (u, p, t) -> u)","category":"page"},{"location":"sketches/algebraicdynamics.html","page":"Lotka-Voltera Two Ways","title":"Lotka-Voltera Two Ways","text":"# Define the composition pattern\nrabbitfox_pattern = WiringDiagram([], [:rabbits, :foxes])\nrabbit_box = add_box!(rabbitfox_pattern, Box(:rabbit, [:pop], [:pop]))\nfox_box = add_box!(rabbitfox_pattern, Box(:fox, [:pop], [:pop]))\n\nadd_wires!(rabbitfox_pattern, Pair[\n    (rabbit_box, 1) => (fox_box, 1),\n    (fox_box, 1)    => (rabbit_box, 1),\n    (rabbit_box, 1) => (output_id(rabbitfox_pattern), 1),\n    (fox_box, 1)    => (output_id(rabbitfox_pattern), 2)\n])","category":"page"},{"location":"sketches/algebraicdynamics.html","page":"Lotka-Voltera Two Ways","title":"Lotka-Voltera Two Ways","text":"# Compose\nrabbitfox_system = ⊕(rabbit, fox; diagram=rabbitfox_pattern, name=\"rabbitfox_system\")","category":"page"},{"location":"sketches/algebraicdynamics.html","page":"Lotka-Voltera Two Ways","title":"Lotka-Voltera Two Ways","text":"# Solve and plot\nu0 = [10.0, 100.0]\nparams = LVector(α=.3, β=0.015, γ=0.015, δ=0.7)\ntspan = (0.0, 100.0)","category":"page"},{"location":"sketches/algebraicdynamics.html","page":"Lotka-Voltera Two Ways","title":"Lotka-Voltera Two Ways","text":"# convert the system to a problem\nprob = DiffEqAgent(rabbitfox_system, u0, tspan, params)","category":"page"},{"location":"sketches/algebraicdynamics.html","page":"Lotka-Voltera Two Ways","title":"Lotka-Voltera Two Ways","text":"# solve the problem\nsimulate(prob)","category":"page"},{"location":"sketches/algebraicdynamics.html","page":"Lotka-Voltera Two Ways","title":"Lotka-Voltera Two Ways","text":"# plot\ndraw(prob; label=[\"rabbits\" \"foxes\"])","category":"page"},{"location":"sketches/algebraicdynamics.html#Open-CPG","page":"Lotka-Voltera Two Ways","title":"Open CPG","text":"","category":"section"},{"location":"sketches/algebraicdynamics.html","page":"Lotka-Voltera Two Ways","title":"Lotka-Voltera Two Ways","text":"using AlgebraicDynamics.CPortGraphDynam\nusing AlgebraicDynamics.CPortGraphDynam: barbell\n\n# Define the composition pattern\nrabbitfox_pattern = barbell(1)","category":"page"},{"location":"sketches/algebraicdynamics.html","page":"Lotka-Voltera Two Ways","title":"Lotka-Voltera Two Ways","text":"rabbitfox_system = ⊕(rabbit, fox; diagram=rabbitfox_pattern, name=\"rabbitfox_system\")","category":"page"},{"location":"sketches/algebraicdynamics.html","page":"Lotka-Voltera Two Ways","title":"Lotka-Voltera Two Ways","text":"# Solve and plot\nu0 = [10.0, 100.0]\nparams = LVector(α=.3, β=0.015, γ=0.015, δ=0.7)\ntspan = (0.0, 100.0)","category":"page"},{"location":"sketches/algebraicdynamics.html","page":"Lotka-Voltera Two Ways","title":"Lotka-Voltera Two Ways","text":"# convert the system to a problem\nprob = DiffEqAgent(rabbitfox_system, u0, tspan, params)","category":"page"},{"location":"sketches/algebraicdynamics.html","page":"Lotka-Voltera Two Ways","title":"Lotka-Voltera Two Ways","text":"# solve the problem\nsimulate(prob)","category":"page"},{"location":"sketches/algebraicdynamics.html","page":"Lotka-Voltera Two Ways","title":"Lotka-Voltera Two Ways","text":"# plot\ndraw(prob; label=[\"rabbits\" \"foxes\"])","category":"page"},{"location":"sketches/sciml.html#SciML-Integration","page":"SciML Integration","title":"SciML Integration","text":"","category":"section"},{"location":"sketches/sciml.html","page":"SciML Integration","title":"SciML Integration","text":"using AlgebraicAgents","category":"page"},{"location":"sketches/sciml.html","page":"SciML Integration","title":"SciML Integration","text":"# declare problems (models in AA's type system)\nusing DifferentialEquations\n\n## vanilla function\nf(u,p,t) = 1.01*u\nu0 = 1/2\ntspan = (0.0,10.0)\nprob = ODEProblem(f,u0,tspan)","category":"page"},{"location":"sketches/sciml.html","page":"SciML Integration","title":"SciML Integration","text":"## atomic models\nm1 = DiffEqAgent(\"model1\", prob)\nm2 = DiffEqAgent(\"model2\", prob)\nm3 = DiffEqAgent(\"model3\", prob)","category":"page"},{"location":"sketches/sciml.html","page":"SciML Integration","title":"SciML Integration","text":"## declare observables (out ports) for a model\n## it will be possible to reference m3's first variable as both `o1`, `o2`\npush_exposed_ports!(m3, \"o1\" => 1, \"o2\" => 1)\n\n## simple function, calls to which will be scheduled during the model integration\ncustom_function(agent, t) = println(\"inside $agent at time $t\")","category":"page"},{"location":"sketches/sciml.html","page":"SciML Integration","title":"SciML Integration","text":"## a bit more intricate logic - \nfunction f_(u,p,t)\n    # access the wrapping agent (hierarchy bond)\n    agent = @get_agent p\n    \n    # access observables \n    ## first via convenient macro syntax\n    o1, o2 = @observables agent \"../model3\":(\"o1\", \"o2\")\n    o1 = @observables agent \"../model3\":\"o1\"\n    ## more explicit notation\n    o1 = getobservable(getagent(agent, \"../model3\"), 1)\n    ## fetch observable's value at **a given time point in the past**\n    o3 = gettimeobservable(getagent(agent, \"../model3\"), t/2, 1)\n\n    # schedule interaction\n    ## first, schedule a call to `_interact!(agent)` with priority 0\n    ## this is the default behavior\n    @schedule agent\n    ## alternatively, provide a function call f(args...)\n    ## this will be expanded to a call f(agent, args...)\n    @schedule_call agent custom_function(t)\n\n    min(2., 1.01*u + o1 + o2 + o3)\nend","category":"page"},{"location":"sketches/sciml.html","page":"SciML Integration","title":"SciML Integration","text":"## yet another atomic model\nprob_ = ODEProblem(f_,u0,tspan)\nm4 = DiffEqAgent(\"model4\", prob_)\n### alternative way to set-up reference \n# m4 = DiffEqAgent(\"model4\", prob_; oref=:__aagent__)\n# m4 = @wrap prob_ ODEProblem(f_,u0,tspan) oref=:__agent__","category":"page"},{"location":"sketches/sciml.html","page":"SciML Integration","title":"SciML Integration","text":"# hierarchical sum of atomic models\nm = ⊕(m1, m2; name=\"diagram1\") ⊕ ⊕(m3, m4; name=\"diagram2\")","category":"page"},{"location":"sketches/sciml.html","page":"SciML Integration","title":"SciML Integration","text":"# explore path-like structure of agents\n\n## index by unix-like path\ngetagent(m, \"diagram1/model1/\")\ngetagent(m, \"diagram1/model1\")\ngetagent(m1, \"../model2\")\ngetagent(m1, \"../../diagram2/model3\")\n\n## index by regex expression\ngetagent(m, r\"model.*\")\n\n## index by glob expression\ngetagent(m, glob\"**/model?/\")\ngetagent(m, glob\"**/model?\"s)","category":"page"},{"location":"sketches/sciml.html","page":"SciML Integration","title":"SciML Integration","text":"# solving the problems\nsol = simulate(m)","category":"page"},{"location":"integrations/AlgebraicDynamicsIntegration.html#AlgebraicDynamics.jl-Integration","page":"AlgebraicDynamics.jl Integration","title":"AlgebraicDynamics.jl Integration","text":"","category":"section"},{"location":"integrations/AlgebraicDynamicsIntegration.html#System-Wrap-Types","page":"AlgebraicDynamics.jl Integration","title":"System Wrap Types","text":"","category":"section"},{"location":"integrations/AlgebraicDynamicsIntegration.html","page":"AlgebraicDynamics.jl Integration","title":"AlgebraicDynamics.jl Integration","text":"GraphicalAgent","category":"page"},{"location":"integrations/AlgebraicDynamicsIntegration.html#AlgebraicAgents.GraphicalAgent","page":"AlgebraicDynamics.jl Integration","title":"AlgebraicAgents.GraphicalAgent","text":"GraphicalAgent(name, model)\n\nInitialize algebraic wrap of either an AbstractResourceSharer or a AbstractMachine.\n\nThe wrapped AbstractResourceSharer or AbstractMachine is stored as the property system.\n\nExamples\n\nGraphicalAgent(\"rabbit\", ContinuousMachine{Float64}(1,1,1, dotr, (u, p, t) -> u))\n\n\n\n\n\n","category":"type"},{"location":"integrations/AlgebraicDynamicsIntegration.html#Conversion-to-a-SciML-Problem","page":"AlgebraicDynamics.jl Integration","title":"Conversion to a SciML Problem","text":"","category":"section"},{"location":"integrations/AlgebraicDynamicsIntegration.html","page":"AlgebraicDynamics.jl Integration","title":"AlgebraicDynamics.jl Integration","text":"DiffEqAgent(::GraphicalAgent, args...)","category":"page"},{"location":"integrations/AlgebraicDynamicsIntegration.html#AlgebraicAgents.DiffEqAgent-Tuple{GraphicalAgent, Vararg{Any}}","page":"AlgebraicDynamics.jl Integration","title":"AlgebraicAgents.DiffEqAgent","text":"DiffEqAgent(agent::GraphicalAgent, u0, tspan, p; alg, kwargs...)\n\nInfer a problem type parametrized by agent.system, and create an appropriate DEProblem. Moreover, wrap this problem as an instance of DiffEqAgent; this contains agent's inner hierarchy.\n\nExamples\n\nDiffEqAgent(system, u0, tspan, params)\nDiffEqAgent(system, u0, tspan, params; alg=Tsit5())\n\n\n\n\n\n","category":"method"},{"location":"integrations/AlgebraicDynamicsIntegration.html#Sums","page":"AlgebraicDynamics.jl Integration","title":"Sums","text":"","category":"section"},{"location":"integrations/AlgebraicDynamicsIntegration.html","page":"AlgebraicDynamics.jl Integration","title":"AlgebraicDynamics.jl Integration","text":"⊕(::GraphicalAgent)","category":"page"},{"location":"integrations/AlgebraicDynamicsIntegration.html#AlgebraicAgents.:⊕-Tuple{GraphicalAgent}","page":"AlgebraicDynamics.jl Integration","title":"AlgebraicAgents.:⊕","text":"⊕(system1, system2; diagram=pattern, name)\n⊕([system1, system2]; diagram=pattern, name)\n⊕(Dict(:system1 => system1, :system2 => system2); diagram=pattern, name)\n\nApply oapply(diagram, systems...) and wrap the result as a GraphicalAgent.\n\n\n\n\n\n","category":"method"},{"location":"design.html#Framework-design","page":"Framework design","title":"Framework design","text":"","category":"section"},{"location":"design.html","page":"Framework design","title":"Framework design","text":"Here we describe the design principles of the AlgebraicAgents. It should be of most use to advanced users and persons interested in contributing to the software. New users are encouraged to start by reading one of the tutorials (\"sketches\").","category":"page"},{"location":"design.html#Simulation-loop","page":"Framework design","title":"Simulation loop","text":"","category":"section"},{"location":"design.html","page":"Framework design","title":"Framework design","text":"We describe here the main simulation loop which steps models built in AlgebraicAgents forward in time.","category":"page"},{"location":"design.html","page":"Framework design","title":"Framework design","text":"AlgebraicAgents keeps agents synchronized by ensuring that the model will only simulate the agent(s) whose projected time (e.g. the maximum time for which that agent's trajectory has been solved) is the minimum of all agents. For example, if there are 3 agents, whose internal step sizes are of 1, 1.5, and 3 time units, respectively, then at the end of the first step, their projected time will be 1, 1.5, and 3 (assuming they all start at time 0). The simulation will find the minimum of those times and only simulate the agent(s) whose projected time(s) are equal to the minimum. In this case, it is the first agent, who is now projected to time 2 on the second step (other agents are not simulated). Now, the new minimum time is 1.5, and the second agent is projected to time 3 on the third step, etc. The simulation continues until all agents have been projected to their final time point, or the minimum of projected times reaches a maximum time horizon. If all agents take time steps of the same size, then they will all be updated each global step.","category":"page"},{"location":"design.html","page":"Framework design","title":"Framework design","text":"There are several functions in the interface for an AbstractAlgebraicAgent which implement these dynamics. When defining new agent types, one should implement the AlgebraicAgents._step! method, which will step that agent forward if its projected time is equal to the least projected time, among all agents in the hierarchy. Agent types also need to implement AlgebraicAgents._projected_to, which is crucial to keeping the simulation synchronized. It will return:","category":"page"},{"location":"design.html","page":"Framework design","title":"Framework design","text":"nothing if the agent does not implement its own _step! rule (e.g. FreeAgent which is a container of agents)\ntrue if the agent has been projected to the final time point (_step! will not be called again)\na value of Number, giving the time point to which the agent has been projected","category":"page"},{"location":"design.html","page":"Framework design","title":"Framework design","text":"These are collected into ret, which is an object that will be true if and only if all agents have returned true, and is otherwise the minimum of the numeric values (projection times) returned from each inner agent's step.","category":"page"},{"location":"design.html","page":"Framework design","title":"Framework design","text":"(Image: )","category":"page"},{"location":"design.html","page":"Framework design","title":"Framework design","text":"Above we show a caricature of the main simulation loop. \"Enter program\" corresponds to the call to simulate, the value of ret is (typically) initialized to 0.0. The simulation continues to step while ret is not true (meaning the maximum time horizon has been reached by the slowest agent), or has not exceeded some maximum. ","category":"page"},{"location":"design.html","page":"Framework design","title":"Framework design","text":"The inner area enclosed by a dashed border represents where program control is given to the step! method. The root agent applies _prestep! recurvisely to all of its inner (enclosed) agents. After this, step! is then applied to all inner agents, and ret is updated by each of them. Then the agent applies its own local update _step! if its own projected time is equal to the minimum of all inner agent projected times (not shown). Then the Opera module for additional interactions is called for the root agent.","category":"page"},{"location":"design.html#Opera","page":"Framework design","title":"Opera","text":"","category":"section"},{"location":"design.html","page":"Framework design","title":"Framework design","text":"The Opera system allows interactions between agents to be scheduled, which will be executed at the end of a time step, sorted by priority. By default, AlgebraicAgents.jl provides support for two types of interactions:","category":"page"},{"location":"design.html","page":"Framework design","title":"Framework design","text":"@schedule is used to schedule a \"wake up\" call to the agent, custom behavior can be implemented by defining AlgebraicAgents._interact! for subtypes of AbstractAlgebraicAgent.\n@schedule_call is used to schedule a callback function to the agent.","category":"page"},{"location":"design.html","page":"Framework design","title":"Framework design","text":"However the system can work with arbitrary types of interactions. To do so, simply define a new call type that is a subtype of AbstractOperaCall. The methods execute_action! and opera_enqueue! must be specialized for your new call type. After that, your new interaction type can be used just like any other! To see an example, please check out our tests.","category":"page"},{"location":"design.html","page":"Framework design","title":"Framework design","text":"For more details, see the API documentation of Opera and our tests.","category":"page"},{"location":"sketches/agents.html#Agents.jl-Integration","page":"Agents.jl Integration","title":"Agents.jl Integration","text":"","category":"section"},{"location":"sketches/agents.html","page":"Agents.jl Integration","title":"Agents.jl Integration","text":"We make use of a SIR model constructor from an Agents.jl' SIR model for the spread of COVID-19 tutorial.","category":"page"},{"location":"sketches/agents.html","page":"Agents.jl Integration","title":"Agents.jl Integration","text":"using AlgebraicAgents","category":"page"},{"location":"sketches/agents.html","page":"Agents.jl Integration","title":"Agents.jl Integration","text":"include(\"../../../tutorials/agents_tutorial/sir_agents_model.jl\")","category":"page"},{"location":"sketches/agents.html","page":"Agents.jl Integration","title":"Agents.jl Integration","text":"# create a sample agent based model\nparams = create_params(C = 8, max_travel_rate = 0.01)\nabm = model_initiation(; params...)","category":"page"},{"location":"sketches/agents.html","page":"Agents.jl Integration","title":"Agents.jl Integration","text":"infected(x) = count(i == :I for i in x)\nrecovered(x) = count(i == :R for i in x)\nto_collect = [(:status, f) for f in (infected, recovered, length)]","category":"page"},{"location":"sketches/agents.html","page":"Agents.jl Integration","title":"Agents.jl Integration","text":"m = ABMAgent(\"sir_model\", abm; agent_step!, tspan=(0., 100.), adata=to_collect)","category":"page"},{"location":"sketches/agents.html","page":"Agents.jl Integration","title":"Agents.jl Integration","text":"# simulate the model\nsimulate(m)","category":"page"},{"location":"integrations/AgentsIntegration.html#Agents.jl-Integration","page":"Agents.jl Integration","title":"Agents.jl Integration","text":"","category":"section"},{"location":"integrations/AgentsIntegration.html","page":"Agents.jl Integration","title":"Agents.jl Integration","text":"The integration can be loaded as:","category":"page"},{"location":"integrations/AgentsIntegration.html#Algebraic-Wrap-Types","page":"Agents.jl Integration","title":"Algebraic Wrap Types","text":"","category":"section"},{"location":"integrations/AgentsIntegration.html","page":"Agents.jl Integration","title":"Agents.jl Integration","text":"ABMAgent\nAAgent","category":"page"},{"location":"integrations/AgentsIntegration.html#AlgebraicAgents.ABMAgent","page":"Agents.jl Integration","title":"AlgebraicAgents.ABMAgent","text":"ABMAgent(name, abm; kwargs...)\n\nInitialize ABMAgent, incl. hierarchy of ABM's agents.\n\nConfigure the evolutionary step, logging, and step size by keyword arguments below.\n\nArguments\n\n- `agent_step!`, `model_step!`: same meaning as in `Agents.step!`\n- in general, any kwarg accepted by `Agents.run!`, incl. `adata`, `mdata`\n- `when`, `when_model`: when to collect agents data, model data\ntrue by default, and performs data collection at every step\nif an `AbstractVector`, checks if `t ∈ when`; otherwise a function (model, t) -> ::Bool\n- `step_size`: how far the step advances, either a float or a function (model, t) -> size::Float64\n- `tspan`: solution horizon, defaults to `(0., Inf)`\n\n\n\n\n\n","category":"type"},{"location":"integrations/AgentsIntegration.html#AlgebraicAgents.AAgent","page":"Agents.jl Integration","title":"AlgebraicAgents.AAgent","text":"Algebraic wrap for AbstractAgent type.\n\n\n\n\n\n","category":"type"},{"location":"integrations/AgentsIntegration.html#Algebraic-Bindings","page":"Agents.jl Integration","title":"Algebraic Bindings","text":"","category":"section"},{"location":"integrations/AgentsIntegration.html","page":"Agents.jl Integration","title":"Agents.jl Integration","text":"@a","category":"page"},{"location":"integrations/AgentsIntegration.html#AlgebraicAgents.@a","page":"Agents.jl Integration","title":"AlgebraicAgents.@a","text":"@a operation\n\nAlgebraic extension of add_agent!, kill_agent!.\n\nExamples\n\n@a add_agent!(model, 0.5)\n@a disentangle!(agent, model)\n\n\n\n\n\n","category":"macro"},{"location":"index.html#API-Documentation","page":"API Documentation","title":"API Documentation","text":"","category":"section"},{"location":"index.html","page":"API Documentation","title":"API Documentation","text":"CurrentModule = AlgebraicAgents","category":"page"},{"location":"index.html#Algebraic-agent-types","page":"API Documentation","title":"Algebraic agent types","text":"","category":"section"},{"location":"index.html","page":"API Documentation","title":"API Documentation","text":"AbstractAlgebraicAgent\nFreeAgent\nFreeAgent(::AbstractString, ::Vector{<:AbstractAlgebraicAgent})","category":"page"},{"location":"index.html#AlgebraicAgents.AbstractAlgebraicAgent","page":"API Documentation","title":"AlgebraicAgents.AbstractAlgebraicAgent","text":"Abstract supertype of all algebraic agents. This is a dynamic structure which parametrizes dynamics of the agent, stores additional data required for the numerical simulation, and optionally logs its state at selected timesteps.\n\n\n\n\n\n","category":"type"},{"location":"index.html#AlgebraicAgents.FreeAgent","page":"API Documentation","title":"AlgebraicAgents.FreeAgent","text":"A container of algebraic agents. Doesn't implement a standalone evolutionary rule; delegates evolution to internal agents.\n\n\n\n\n\n","category":"type"},{"location":"index.html#AlgebraicAgents.FreeAgent-Tuple{AbstractString, Vector{<:AbstractAlgebraicAgent}}","page":"API Documentation","title":"AlgebraicAgents.FreeAgent","text":"FreeAgent(name, agents=[])\n\nInitialize an algebraic agent. Optionally provide contained agents at the time of instantiation. See also entangle! and disentangle!.\n\nExamples\n\nFreeAgent(\"agent\", [agent1, agent2])\n\n\n\n\n\n","category":"method"},{"location":"index.html#Implementing-custom-types","page":"API Documentation","title":"Implementing custom types","text":"","category":"section"},{"location":"index.html","page":"API Documentation","title":"API Documentation","text":"To implement a custom algebraic agent type, you may want to use the convenience macro @aagent which supplies type fields expected (not required, though) by the interface.","category":"page"},{"location":"index.html","page":"API Documentation","title":"API Documentation","text":"Next step is to implement the required interface functions:","category":"page"},{"location":"index.html","page":"API Documentation","title":"API Documentation","text":"AlgebraicAgents._step!(::AbstractAlgebraicAgent)\nAlgebraicAgents._projected_to(::AbstractAlgebraicAgent)\nAlgebraicAgents.getobservable(::AbstractAlgebraicAgent, ::Any)","category":"page"},{"location":"index.html#AlgebraicAgents._step!-Tuple{AbstractAlgebraicAgent}","page":"API Documentation","title":"AlgebraicAgents._step!","text":"Step an agent forward (call only if its projected time is equal to the least projected time, among all agents in the hierarchy).\n\n\n\n\n\n","category":"method"},{"location":"index.html#AlgebraicAgents._projected_to-Tuple{AbstractAlgebraicAgent}","page":"API Documentation","title":"AlgebraicAgents._projected_to","text":"Return time to which algebraic agent's evolution was projected.\n\n\n\n\n\n","category":"method"},{"location":"index.html#AlgebraicAgents.getobservable-Tuple{AbstractAlgebraicAgent, Any}","page":"API Documentation","title":"AlgebraicAgents.getobservable","text":"getobservable(agent, args...)\n\nGet algebraic agent's observable.\n\nExamples\n\ngetobservable(getagent(agent, \"../model\"), \"observable_name\")\ngetobservable(getagent(agent, \"../model\"), 1)\n\n\n\n\n\n","category":"method"},{"location":"index.html","page":"API Documentation","title":"API Documentation","text":"For a deeper integration of the agent type, you may specialize the following functions:","category":"page"},{"location":"index.html","page":"API Documentation","title":"API Documentation","text":"AlgebraicAgents._getparameters(::AbstractAlgebraicAgent)\nAlgebraicAgents._setparameters!(::AbstractAlgebraicAgent, ::Any)\nAlgebraicAgents._draw(::AbstractAlgebraicAgent)\nAlgebraicAgents._reinit!(::AbstractAlgebraicAgent)\nAlgebraicAgents._interact!(::AbstractAlgebraicAgent)\nAlgebraicAgents._prestep!(::AbstractAlgebraicAgent, ::Float64)\n_construct_agent(::AbstractString, args...)\n_get_agent(::Any, args...)","category":"page"},{"location":"index.html#AlgebraicAgents._getparameters-Tuple{AbstractAlgebraicAgent}","page":"API Documentation","title":"AlgebraicAgents._getparameters","text":"_getparameters(agent)\n\nRetrieve parameter space of an algebraic agent.\n\n\n\n\n\n","category":"method"},{"location":"index.html#AlgebraicAgents._setparameters!-Tuple{AbstractAlgebraicAgent, Any}","page":"API Documentation","title":"AlgebraicAgents._setparameters!","text":"_setparameters!\n\nMutate algebraic agent's parameter space.\n\nExamples\n\n_setparameters!(agent, Dict(:α=>1))\n_setparameters!(agent, [1., 2.])\n\n\n\n\n\n","category":"method"},{"location":"index.html#AlgebraicAgents._draw-Tuple{AbstractAlgebraicAgent}","page":"API Documentation","title":"AlgebraicAgents._draw","text":"Return plot of an algebraic agent's state. Defaults to nothing.\n\n\n\n\n\n","category":"method"},{"location":"index.html#AlgebraicAgents._reinit!-Tuple{AbstractAlgebraicAgent}","page":"API Documentation","title":"AlgebraicAgents._reinit!","text":"Reinitialize the state of an algebraic agent.\n\n\n\n\n\n","category":"method"},{"location":"index.html#AlgebraicAgents._interact!-Tuple{AbstractAlgebraicAgent}","page":"API Documentation","title":"AlgebraicAgents._interact!","text":"Wake up an agent. See Opera.\n\n\n\n\n\n","category":"method"},{"location":"index.html#AlgebraicAgents._prestep!-Tuple{AbstractAlgebraicAgent, Float64}","page":"API Documentation","title":"AlgebraicAgents._prestep!","text":"Pre-step to a step call (e.g., projecting algebraic agent's solution up to time t).\n\n\n\n\n\n","category":"method"},{"location":"index.html#AlgebraicAgents._construct_agent-Tuple{AbstractString, Vararg{Any}}","page":"API Documentation","title":"AlgebraicAgents._construct_agent","text":"Specialize the function to support convenience wrap initialization, dispatched on the arguments' types. See @wrap. \n\n\n\n\n\n","category":"method"},{"location":"index.html#AlgebraicAgents._get_agent-Tuple{Any, Vararg{Any}}","page":"API Documentation","title":"AlgebraicAgents._get_agent","text":"Extract algebraic wrap from obj.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Loading-third-party-package-integrations","page":"API Documentation","title":"Loading third-party package integrations","text":"","category":"section"},{"location":"index.html","page":"API Documentation","title":"API Documentation","text":"So far, integrations of DifferentialEquations.jl, Agents.jl, and AlgebraicDynamics.jl are provided.","category":"page"},{"location":"index.html","page":"API Documentation","title":"API Documentation","text":"Loading of the integrations is facilitated by Requires.jl; the integration will automatically be included once the respective third-party package is loaded.","category":"page"},{"location":"index.html","page":"API Documentation","title":"API Documentation","text":"For example,","category":"page"},{"location":"index.html","page":"API Documentation","title":"API Documentation","text":"using AlgebraicAgents\n@isdefined DiffEqAgent","category":"page"},{"location":"index.html","page":"API Documentation","title":"API Documentation","text":"using AlgebraicAgents, DifferentialEquations\n@wrap my_model ODEProblem((u, p, t) -> 1.01*u, [1/2], (0., 10.))","category":"page"},{"location":"index.html","page":"API Documentation","title":"API Documentation","text":"For plotting, you will want to load Plots as well. Nevertheless, function draw will inform you when necessary.","category":"page"},{"location":"index.html#Common-interface","page":"API Documentation","title":"Common interface","text":"","category":"section"},{"location":"index.html#Agent-properties-accessors","page":"API Documentation","title":"Agent properties accessors","text":"","category":"section"},{"location":"index.html","page":"API Documentation","title":"API Documentation","text":"getname\ngetuuid\ngetparent\ninners\ngetopera\ngetdirectory\ngetparameters\nsetparameters!","category":"page"},{"location":"index.html#AlgebraicAgents.getname","page":"API Documentation","title":"AlgebraicAgents.getname","text":"getname(agent)\n\nGet algebraic agent's name.\n\n\n\n\n\n","category":"function"},{"location":"index.html#AlgebraicAgents.getuuid","page":"API Documentation","title":"AlgebraicAgents.getuuid","text":"getuuid(agent)\n\nGet algebraic agent's uuid.\n\n\n\n\n\n","category":"function"},{"location":"index.html#AlgebraicAgents.getparent","page":"API Documentation","title":"AlgebraicAgents.getparent","text":"getparent(agent)\n\nGet algebraic agent's parent.\n\n\n\n\n\n","category":"function"},{"location":"index.html#AlgebraicAgents.inners","page":"API Documentation","title":"AlgebraicAgents.inners","text":"inners(agent)\n\nGet dictionary of algebraic agent's inner agents. Follows name => agent format.\n\n\n\n\n\n","category":"function"},{"location":"index.html#AlgebraicAgents.getopera","page":"API Documentation","title":"AlgebraicAgents.getopera","text":"Get algebraic agent's Opera.\n\n\n\n\n\n","category":"function"},{"location":"index.html#AlgebraicAgents.getdirectory","page":"API Documentation","title":"AlgebraicAgents.getdirectory","text":"Get algebraic agent's directory. See also Opera.\n\n\n\n\n\n","category":"function"},{"location":"index.html#AlgebraicAgents.getparameters","page":"API Documentation","title":"AlgebraicAgents.getparameters","text":"getparameters(agent)\n\nRetrieve algebraic agents' (incl. inner agents, if applicable) parameter space.\n\n\n\n\n\n","category":"function"},{"location":"index.html#AlgebraicAgents.setparameters!","page":"API Documentation","title":"AlgebraicAgents.setparameters!","text":"setparameters!(agent, parameters)\n\nAssign algebraic agent's parameters. Parameters are accepted in the form of a dictionary containing path => params pairs.\n\nExamples\n\nsetparameters!(agent, Dict(\"agent1/agent2\" => Dict(:α=>1)))\n\n\n\n\n\n","category":"function"},{"location":"index.html#Accessors","page":"API Documentation","title":"Accessors","text":"","category":"section"},{"location":"index.html","page":"API Documentation","title":"API Documentation","text":"getobservable\ngettimeobservable","category":"page"},{"location":"index.html#AlgebraicAgents.getobservable","page":"API Documentation","title":"AlgebraicAgents.getobservable","text":"getobservable(agent, args...)\n\nGet algebraic agent's observable.\n\nExamples\n\ngetobservable(getagent(agent, \"../model\"), \"observable_name\")\ngetobservable(getagent(agent, \"../model\"), 1)\n\n\n\n\n\n","category":"function"},{"location":"index.html#AlgebraicAgents.gettimeobservable","page":"API Documentation","title":"AlgebraicAgents.gettimeobservable","text":"Get algebraic agent's observable at a given time.\n\n\n\n\n\n","category":"function"},{"location":"index.html#List-observables-observed-by-an-agent-and-exported-by-an-agent","page":"API Documentation","title":"List observables observed by an agent and exported by an agent","text":"","category":"section"},{"location":"index.html","page":"API Documentation","title":"API Documentation","text":"ports_in\nexposed_ports","category":"page"},{"location":"index.html#AlgebraicAgents.ports_in","page":"API Documentation","title":"AlgebraicAgents.ports_in","text":"Return a list of algebraic agent's inner ports (subjective observables).\n\n\n\n\n\n","category":"function"},{"location":"index.html#AlgebraicAgents.exposed_ports","page":"API Documentation","title":"AlgebraicAgents.exposed_ports","text":"Return a list of algebraic agent's outer ports (objective observables).\n\n\n\n\n\n","category":"function"},{"location":"index.html#Solving-and-plotting","page":"API Documentation","title":"Solving & plotting","text":"","category":"section"},{"location":"index.html","page":"API Documentation","title":"API Documentation","text":"step!\nsimulate\ndraw","category":"page"},{"location":"index.html#AlgebraicAgents.step!","page":"API Documentation","title":"AlgebraicAgents.step!","text":"step!(agent, t=projected_to(agent))\n\nPerforms a single evolutionary step of the algebraic hierarchy. To avoid frontrunning, solutions will be projected only up to time t. This is a two-phase step; the corresponding stepping functions are_prestep!andstep!`.\n\nMore particular behavior can be implemented using Opera protocol.\n\nFor custom algebraic agents' types, it suffices to implement _step!.\n\nReturn values\n\nReturn true if all internal algebraic agent's time horizon was reached. Else return the minimum time up to which the algebraic agent's solution was projected.\n\n\n\n\n\n","category":"function"},{"location":"index.html#AlgebraicAgents.simulate","page":"API Documentation","title":"AlgebraicAgents.simulate","text":"simulate(agent::AbstractAlgebraicAgent, max_t=Inf)::AbstractAlgebraicAgent\n\nSolves an (initialized) algebraic problem.  Runs a loop until all the agents return true (reached simulation horizon) or nothing (delegated evolution), or until the simulation horizon reaches max_t. Avoids front-running.\n\nExamples\n\nsol = simulate(model)\n\n\n\n\n\n","category":"function"},{"location":"index.html#AlgebraicAgents.draw","page":"API Documentation","title":"AlgebraicAgents.draw","text":"Plot an algebraic agent's state. For internal implementation, see _draw.\n\n\n\n\n\n","category":"function"},{"location":"index.html#Paths","page":"API Documentation","title":"Paths","text":"","category":"section"},{"location":"index.html","page":"API Documentation","title":"API Documentation","text":"Implements path-like structure of agents.","category":"page"},{"location":"index.html","page":"API Documentation","title":"API Documentation","text":"@glob_str\n@uuid_str\ngetagent\nby_name","category":"page"},{"location":"index.html#AlgebraicAgents.@glob_str","page":"API Documentation","title":"AlgebraicAgents.@glob_str","text":"Returns a glob string to enable wildcard matching of algebraic agents paths.\n\n\n\n\n\n","category":"macro"},{"location":"index.html#AlgebraicAgents.@uuid_str","page":"API Documentation","title":"AlgebraicAgents.@uuid_str","text":"Returns UUID object given a uuid string.\n\n\n\n\n\n","category":"macro"},{"location":"index.html#AlgebraicAgents.getagent","page":"API Documentation","title":"AlgebraicAgents.getagent","text":"Retrieve an algebraic agent at path, relatively to agent.\n\n\n\n\n\ngetagent(a::AbstractAlgebraicAgent, uuid::UUID)\n\nGet an algebraic agent given its uuid.\n\nExamples\n\ngetagent(a, UUID(\"2a634aad-0fbe-4a91-a605-bfbef4d57f95\"))\ngetagent(a, uuid\"2a634aad-0fbe-4a91-a605-bfbef4d57f95\")\n\n\n\n\n\ngetagent(agent::AbstractAlgebraicAgent, path::AbstractString)\n\nGet an algebraic agent given its relative path.\n\nExamples\n\ngetagent(a, \"../agent\")\n\n\n\n\n\ngetagent(agent::AbstractAlgebraicAgent, path::Union{Glob.FilenameMatch, Regex})\n\nGet an algebraic agent given a regex or glob string.\n\nExamples\n\ngetagent(a, r\"agent.*\")\ngetagent(a, glob\"**/agent/\")\n\n\n\n\n\n","category":"function"},{"location":"index.html#AlgebraicAgents.by_name","page":"API Documentation","title":"AlgebraicAgents.by_name","text":"by_name(agent, name::AbstractString; inners_only=false)\n\nReturn agents in the hierachy with the given name. If inners_only==true, consider descendants of agent only.\n\n\n\n\n\nby_name(agent, name::Union{Glob.FilenameMatch, Regex})\n\nReturn agents in the hierarchy whose names match the given wildcard. If inners_only==true, consider descendants of agent only.\n\n\n\n\n\n","category":"function"},{"location":"index.html#Opera,-a-dynamic-structure-to-facilitate-complex-interactions","page":"API Documentation","title":"Opera, a dynamic structure to facilitate complex interactions","text":"","category":"section"},{"location":"index.html","page":"API Documentation","title":"API Documentation","text":"Opera\nAbstractOperaCall\nAgentCall\nopera_enqueue!","category":"page"},{"location":"index.html#AlgebraicAgents.Opera","page":"API Documentation","title":"AlgebraicAgents.Opera","text":"Opera(uuid2agent_pairs...)\n\nA dynamic structure that stores a priority queue of algebraic interactions and contains a directory of algebraic agents (dictionary of uuid => agent pairs).\n\nAlgebraic Interactions\n\nIt is possible to schedule additional interactions within the complex; such actions are instances of AbstractOperaCall, and they are modeled as tuples (priority=0., call).\n\nAt the end of the topmost call to step!, the actions will be executed one-by-one in order of the respective priorities.\n\nIn particular, you may schedule interactions of two kinds:\n\n@schedule agent priority=0, which will translate into a call _interact!(agent),\n@schedule_call agent f(args...) priority=0 or @schedule_call agent x->ex priority=0,\n\nwhich will translate into a call agent->f(agent, args...) or (x->ex)(agent), respectively.\n\nSee @schedule and @schedule_call.\n\nThey exist within a single step of the model and are executed after the calls to _prestep! and _step! finish. \n\nSee opera_enqueue!.\n\n\n\n\n\n","category":"type"},{"location":"index.html#AlgebraicAgents.AbstractOperaCall","page":"API Documentation","title":"AlgebraicAgents.AbstractOperaCall","text":"Abstract opera interaction. See Opera.\n\n\n\n\n\n","category":"type"},{"location":"index.html#AlgebraicAgents.AgentCall","page":"API Documentation","title":"AlgebraicAgents.AgentCall","text":"A scheduled call to an agent. See Opera.\n\n\n\n\n\n","category":"type"},{"location":"index.html#AlgebraicAgents.opera_enqueue!","page":"API Documentation","title":"AlgebraicAgents.opera_enqueue!","text":"Schedule an algebraic interaction.\n\n\n\n\n\n","category":"function"},{"location":"index.html#Operations","page":"API Documentation","title":"Operations","text":"","category":"section"},{"location":"index.html","page":"API Documentation","title":"API Documentation","text":"Defines sums of agents.","category":"page"},{"location":"index.html","page":"API Documentation","title":"API Documentation","text":"⊕\n@sum","category":"page"},{"location":"index.html#AlgebraicAgents.:⊕","page":"API Documentation","title":"AlgebraicAgents.:⊕","text":"⊕(models::Vararg{AbstractAlgebraicAgent, N}; name)\n\nAlgebraic sum of algebraic models. Optionally specify resulting model's name.\n\nBy default, outputs an instance of FreeAgent.\n\nExamples\n\n⊕(m1, m2; name=\"diagram1\") ⊕ ⊕(m3, m4; name=\"diagram2\");\n\n\n\n\n\n⊕(system1, system2; diagram=pattern, name)\n⊕([system1, system2]; diagram=pattern, name)\n⊕(Dict(:system1 => system1, :system2 => system2); diagram=pattern, name)\n\nApply oapply(diagram, systems...) and wrap the result as a GraphicalAgent.\n\n\n\n\n\n⊕(system1, system2; diagram=pattern, name)\n⊕([system1, system2]; diagram=pattern, name)\n⊕(Dict(:system1 => system1, :system2 => system2); diagram=pattern, name)\n\nApply oapply(diagram, systems...) and wrap the result as a GraphicalAgent.\n\n\n\n\n\n⊕(system1, system2; diagram=pattern, name)\n⊕([system1, system2]; diagram=pattern, name)\n⊕(Dict(:system1 => system1, :system2 => system2); diagram=pattern, name)\n\nApply oapply(diagram, systems...) and wrap the result as a GraphicalAgent.\n\n\n\n\n\n⊕(system1, system2; diagram=pattern, name)\n⊕([system1, system2]; diagram=pattern, name)\n⊕(Dict(:system1 => system1, :system2 => system2); diagram=pattern, name)\n\nApply oapply(diagram, systems...) and wrap the result as a GraphicalAgent.\n\n\n\n\n\n","category":"function"},{"location":"index.html#AlgebraicAgents.@sum","page":"API Documentation","title":"AlgebraicAgents.@sum","text":"@sum models...\n\nPerform an algebraic sum of algebraic models (flatten arguments to ⊕).\n\nExamples\n\n@sum m1 m2 m3 m4 # == ⊕(m1, m2, m3, m4)\n\n\n\n\n\n","category":"macro"},{"location":"index.html","page":"API Documentation","title":"API Documentation","text":"Entangle and disentangle agents hierarchies.","category":"page"},{"location":"index.html","page":"API Documentation","title":"API Documentation","text":"entangle!\ndisentangle!","category":"page"},{"location":"index.html#AlgebraicAgents.entangle!","page":"API Documentation","title":"AlgebraicAgents.entangle!","text":"entangle!(parent, agent)\n\nPush an agent to the hierachy.\n\nExamples\n\nentagle!(parent, ancestor)\n\n\n\n\n\n","category":"function"},{"location":"index.html#AlgebraicAgents.disentangle!","page":"API Documentation","title":"AlgebraicAgents.disentangle!","text":"disentangle!(agent)\n\nDetach an agent from its parent. Optionally set remove_relpathrefs=false keyword to skip removing the relative pathrefs.\n\nExamples\n\ndisentangle!(agent)\n\n\n\n\n\n","category":"function"},{"location":"index.html#Agent-type-constructors","page":"API Documentation","title":"Agent type constructors","text":"","category":"section"},{"location":"index.html","page":"API Documentation","title":"API Documentation","text":"Supports convenient agent subtyping.","category":"page"},{"location":"index.html","page":"API Documentation","title":"API Documentation","text":"@aagent","category":"page"},{"location":"index.html#AlgebraicAgents.@aagent","page":"API Documentation","title":"AlgebraicAgents.@aagent","text":"@aagent [OptionalBasetype=FreeAgent] [OptionalSupertype=AbstractAlgebraicAgent] struct my_agent\n    extra_fields...\nend\n\nCreate a custom algebraic agent type, and include fields expected by default interface methods (see FreeAgent).\n\nFields are mutable by default, but can be made immutable using const keyword.\n\nProvides a constructor which takes agent's name at the input, and populates the common fields.\n\nExample\n\n@aagent struct Molecule\n    age::Float64\n    birth_time::Float64\n    sales::Float64\nend\n\nOptional base type:\n\n@aagent FreeAgent struct Molecule\n    age::Float64\n    birth_time::Float64\n    sales::Float64\nend\n\nOptional base type and a super type:\n\n@aagent FreeAgent AbstractMolecule struct Molecule\n    age::Float64\n    birth_time::Float64\n    sales::Float64\nend\n\nParametric types:\n\n@aagent struct MyAgent{T <: Real, P <: Real}\n    field1::T\n    field2::P\nend\n\nMyAgent{Float64, Int}(\"myagent\", 1, 2)\n\n\n\n\n\n","category":"macro"},{"location":"index.html","page":"API Documentation","title":"API Documentation","text":"To provide custom specialization of @aagent convenience macros, see AlgebraicAgents.define_agent.","category":"page"},{"location":"index.html","page":"API Documentation","title":"API Documentation","text":"AlgebraicAgents.define_agent","category":"page"},{"location":"index.html#AlgebraicAgents.define_agent","page":"API Documentation","title":"AlgebraicAgents.define_agent","text":"define_agent(base_type, super_type, type, __module, constructor)\n\nA function to define an agent type. See the definition of @aagent.\n\n\n\n\n\n","category":"function"},{"location":"index.html#Walks","page":"API Documentation","title":"Walks","text":"","category":"section"},{"location":"index.html","page":"API Documentation","title":"API Documentation","text":"Walk agents' hierarchy.","category":"page"},{"location":"index.html","page":"API Documentation","title":"API Documentation","text":"prewalk\npostwalk","category":"page"},{"location":"index.html#AlgebraicAgents.prewalk","page":"API Documentation","title":"AlgebraicAgents.prewalk","text":"Applies f to each algebraic agent, returning the result. Applies f to an agent before visiting its inners.\n\n\n\n\n\n","category":"function"},{"location":"index.html#AlgebraicAgents.postwalk","page":"API Documentation","title":"AlgebraicAgents.postwalk","text":"Applies f to each algebraic agent, returning the result. Applies f to an agent before visiting its inners.\n\n\n\n\n\n","category":"function"},{"location":"index.html#Utility-functions","page":"API Documentation","title":"Utility functions","text":"","category":"section"},{"location":"index.html#Initialize-wrap,-extract-wrap","page":"API Documentation","title":"Initialize wrap, extract wrap","text":"","category":"section"},{"location":"index.html","page":"API Documentation","title":"API Documentation","text":"@wrap\n@get_agent","category":"page"},{"location":"index.html#AlgebraicAgents.@wrap","page":"API Documentation","title":"AlgebraicAgents.@wrap","text":"@wrap name args... kwargs...\n\nA convenience macro to initialize an algebraic wrap, dispatched on the arguments' types. See _construct_agent.\n\nExamples\n\n@wrap \"ode_agent\" prob ODEProblem(f, u0, tspan)\n@wrap ode_agent prob ODEProblem(f, u0, tspan)\n\n\n\n\n\n","category":"macro"},{"location":"index.html#AlgebraicAgents.@get_agent","page":"API Documentation","title":"AlgebraicAgents.@get_agent","text":"@get_agent obj\n\nExtract algebraic wrap from obj. Reduces to _get_agent, as overloaded by third-party packages integrations.\n\nExamples\n\nwrap = @get_agent params # for SciML integration\nwrap = @get_agent model agent # for ABM integration\n\n\n\n\n\n","category":"macro"},{"location":"index.html#Observable-accessor,-interaction-schedulers","page":"API Documentation","title":"Observable accessor, interaction schedulers","text":"","category":"section"},{"location":"index.html","page":"API Documentation","title":"API Documentation","text":"@observables\n@schedule\n@schedule_call","category":"page"},{"location":"index.html#AlgebraicAgents.@observables","page":"API Documentation","title":"AlgebraicAgents.@observables","text":"@observables agent path:obs path:(obs1, obs2) path:[obs1, obs2]\n\nRetrieve (a vector of) observables relative to agent.\n\nExamples\n\n@observables agent \"../agent\":\"o\"\n@observables agent \"../agent\":(\"o1\", \"o2\")\n\n\n\n\n\n","category":"macro"},{"location":"index.html#AlgebraicAgents.@schedule","page":"API Documentation","title":"AlgebraicAgents.@schedule","text":"@schedule agent priority=0\n\nSchedule an interaction. Interactions are implemented within an instance Opera, sorted by their priorities. Internally, reduces to _interact!(agent).\n\nSee also Opera.\n\nExamples\n\n@schedule agent 1.\n\n\n\n\n\n","category":"macro"},{"location":"index.html#AlgebraicAgents.@schedule_call","page":"API Documentation","title":"AlgebraicAgents.@schedule_call","text":"@schedule agent call priority=0\n\nSchedule an interaction (call). Interactions are implemented within an instance Opera, sorted by their priorities. Internally, the call=f(args...) expression will be transformed to an anonymous function agent -> f(agent, args...).\n\nSee also Opera.\n\nExamples\n\n@schedule agent f(t)\n\n\n\n\n\n","category":"macro"},{"location":"index.html#Flat-representation","page":"API Documentation","title":"Flat representation","text":"","category":"section"},{"location":"index.html","page":"API Documentation","title":"API Documentation","text":"flatten","category":"page"},{"location":"index.html#AlgebraicAgents.flatten","page":"API Documentation","title":"AlgebraicAgents.flatten","text":"flatten(root_agent)\n\nReturn flat representation of algebraic agents hierarchy.\n\n\n\n\n\n","category":"function"},{"location":"index.html#Default-plots-for-custom-agent-types","page":"API Documentation","title":"Default plots for custom agent types","text":"","category":"section"},{"location":"index.html","page":"API Documentation","title":"API Documentation","text":"@draw_df","category":"page"},{"location":"index.html#AlgebraicAgents.@draw_df","page":"API Documentation","title":"AlgebraicAgents.@draw_df","text":"@draw_df T field\n\nA macro to define _draw(T) such that it will plot a DataFrame stored under field.\n\nRequires DataFrames and Plots to be available.\n\nExamples\n\n@draw_df my_type log # will plot `log` property (a DataFrame) of `my_type`'s instance\n\n\n\n\n\n","category":"macro"},{"location":"index.html#Queries","page":"API Documentation","title":"Queries","text":"","category":"section"},{"location":"index.html","page":"API Documentation","title":"API Documentation","text":"It is possible to run filter and transform queries on agent hierarchies.","category":"page"},{"location":"index.html#Filter-queries","page":"API Documentation","title":"Filter queries","text":"","category":"section"},{"location":"index.html","page":"API Documentation","title":"API Documentation","text":"GeneralFilterQuery\n@f_str\n@filter\nAlgebraicAgents.filter(::AbstractAlgebraicAgent, ::GeneralFilterQuery)","category":"page"},{"location":"index.html#AlgebraicAgents.GeneralFilterQuery","page":"API Documentation","title":"AlgebraicAgents.GeneralFilterQuery","text":"GeneralFilterQuery(query)\n\nSimple property query; references agents via underscores _.\n\nA query on an agent may result in an error; in that case, the agent will fail the filter condition by default.\n\nSee also @f_str, filter.\n\nExamples\n\nfilter(agents, f\"_.age > 21 && _.name ∈ ['a', 'b']\")\nagents |> @filter _.age > 21 && _.name ∈ ['a', 'b']\n\n\n\n\n\n","category":"type"},{"location":"index.html#AlgebraicAgents.@f_str","page":"API Documentation","title":"AlgebraicAgents.@f_str","text":"f\"query\"\n\nTurn a query string into a query instance, see also GeneralFilterQuery.\n\nSupports string interpolations.\n\nExamples\n\nfilter(agents, f\"_.age > 1 && _.name ∈ ['a', 'b']\")\ni = 1; filter(agents, f\"_.age > $i && _.name ∈ ['a', 'b']\")\n\n\n\n\n\n","category":"macro"},{"location":"index.html#AlgebraicAgents.@filter","page":"API Documentation","title":"AlgebraicAgents.@filter","text":"@filter query\n\nTurnfilter query into a function of agents' hierarchy. Accepts expressions (corresponding to q-strings) and query string.\n\nSee also GeneralFilterQuery.\n\n\n\n\n\n","category":"macro"},{"location":"index.html#Base.filter-Tuple{AbstractAlgebraicAgent, GeneralFilterQuery}","page":"API Documentation","title":"Base.filter","text":"filter(agent::AbstractAlgebraicAgent, queries...)\nfilter(agents::Vector{<:AbstractAlgebraicAgent}, queries...)\n\nRun filter query on agents in a hierarchy.\n\nExamples\n\nfilter(agent, f\"_.age > 21 && _.name ∈ ['a', 'b']\") # filter query\n\n\n\n\n\n","category":"method"},{"location":"index.html","page":"API Documentation","title":"API Documentation","text":"To provide custom filter query types, you need to implement AlgebraicAgents._filter low-level matching method.","category":"page"},{"location":"index.html","page":"API Documentation","title":"API Documentation","text":"AlgebraicAgents._filter","category":"page"},{"location":"index.html#AlgebraicAgents._filter","page":"API Documentation","title":"AlgebraicAgents._filter","text":"_filter(agent, query)\n\nCheck if an agent satisfies filter condition.\n\n\n\n\n\n","category":"function"},{"location":"index.html#Transform-queries","page":"API Documentation","title":"Transform queries","text":"","category":"section"},{"location":"index.html","page":"API Documentation","title":"API Documentation","text":"GeneralTransformQuery\n@transform\ntransform","category":"page"},{"location":"index.html#AlgebraicAgents.GeneralTransformQuery","page":"API Documentation","title":"AlgebraicAgents.GeneralTransformQuery","text":"GeneralTransformQuery(name, query)\n\nSimple transform query; references agents via underscores _.\n\nSee also @transform.\n\nExamples\n\nagent |> @transform(name=_.name)\nagent |> @transform(name=_.name, _.age)\n\n\n\n\n\n","category":"type"},{"location":"index.html#AlgebraicAgents.@transform","page":"API Documentation","title":"AlgebraicAgents.@transform","text":"@transform queries...\n\nTurn transform queries into an anonymous function of agents' hierarchy. See also GeneralTransformQuery.\n\nAccepts both anonymous queries (_.name) and named queries (name=_.name). By default, includes agent's uuid.\n\n\n\n\n\n","category":"macro"},{"location":"index.html#AlgebraicAgents.transform","page":"API Documentation","title":"AlgebraicAgents.transform","text":"transform(agent::AbstractAlgebraicAgent, queries...)\ntranform(agent::Vector{<:AbstractAlgebraicAgent}, queries...)\n\nRun transform query on agents in a hierarchy.\n\nA query on an agent may result in an error; in that case, the respective agent's output is omitted for the result.\n\nSee also @transform.\n\nExamples\n\nagent |> @transform(name=_.name)\nagent |> @transform(name=_.name, _.age)\n\n\n\n\n\n","category":"function"},{"location":"integrations/SciMLIntegration.html#SciML-Integration","page":"SciML Integration","title":"SciML Integration","text":"","category":"section"},{"location":"integrations/SciMLIntegration.html#Problem-Wrap-Type","page":"SciML Integration","title":"Problem Wrap Type","text":"","category":"section"},{"location":"integrations/SciMLIntegration.html","page":"SciML Integration","title":"SciML Integration","text":"DiffEqAgent","category":"page"},{"location":"integrations/SciMLIntegration.html#AlgebraicAgents.DiffEqAgent","page":"SciML Integration","title":"AlgebraicAgents.DiffEqAgent","text":"DiffEqAgent(name, problem[, alg]; exposed_ports=nothing, ports_in=nothing, kwargs...)\n\nInitialize DE problem algebraic wrap. \n\nKeywords\n\nexposed_ports: either nothing or a dictionary which maps keys to observable's positional index in u,\nports_in: either nothing or a vector of (subjective) observables,\nother kwargs will be propagated to the integrator at initialization step.\n\n\n\n\n\n","category":"type"},{"location":"integrations/SciMLIntegration.html#Observables","page":"SciML Integration","title":"Observables","text":"","category":"section"},{"location":"integrations/SciMLIntegration.html","page":"SciML Integration","title":"SciML Integration","text":"push_ports_in!\npush_exposed_ports!","category":"page"},{"location":"integrations/SciMLIntegration.html#AlgebraicAgents.push_ports_in!","page":"SciML Integration","title":"AlgebraicAgents.push_ports_in!","text":"push_ports_in!(a::DiffEqAgent, pairs...)\n\nRegister explicit in-ports of an algebraic DiffEq model. Provide pairs path => observable, where observable may optionally be an iterable collection of observables' names.\n\nExamples\n\npush_ports_in!(deagent, path => observable, path => [observables...])\n\n\n\n\n\n","category":"function"},{"location":"integrations/SciMLIntegration.html#AlgebraicAgents.push_exposed_ports!","page":"SciML Integration","title":"AlgebraicAgents.push_exposed_ports!","text":"push_exposed_ports!(a::DiffEqAgent, pairs...)\n\nRegister explicit out-ports of an algebraic DiffEq model.  Enables aliasing of variable's positional index. That is, provide key => ix pair to alias ixth model's variable as key.\n\nExamples\n\npush_exposed_ports!(deagent, key => ix1, ix2)\n\n\n\n\n\n","category":"function"}]
}
